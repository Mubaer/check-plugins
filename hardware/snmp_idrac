#!/usr/bin/env bash

# This plugin retrieves various informations from Dell iDRAC Boards.
#
# Author: msander
#
# Version: 0.1  2023-03-29
#   first test version
#

# Define Vars
declare -A snmpData
declare -A id
declare -A nameMap
declare -a elementList

glob_rcode=0

#
# CLI Parsing
#

OPTERR=1
while getopts "H:C:u:x:X:a:A:l:w:c:m:f:F:t:Bhd" OPTION ; do
    case "${OPTION}" in
        H) hostname=${OPTARG}       ;;
        C) community="-c ${OPTARG}" ;;
        u) authuser="-u ${OPTARG}"  ;;
        a) authproto="-a ${OPTARG}" ;;
        A) authpass="-A ${OPTARG}"  ;;
        x) privproto="-x ${OPTARG}" ;;
        X) privpass="-X ${OPTARG}"  ;;
        l) seclevel="-l ${OPTARG}"  ;;
        w) warn=${OPTARG}           ;;
        c) crit=${OPTARG}           ;;
        m) mode=${OPTARG}           ;;
        f) filter=${OPTARG}         ;;
        F) neg_filter=${OPTARG}     ;;
        t) tout=${OPTARG}           ;;
        B) nobulk=1                 ;;
        h) helpme=1                 ;;
        d) debug=1                  ;;
    esac
done

#######
# Functions
#######

function check_arguments {
        if [ -z "$hostname" ] ; then
                echo "$0 required argument -H <hostname> missing"
                exit 3
        elif [ -z "$authuser" -a -z "$community" ] ; then
                echo "$0 SNMP credentials missing: either -C <community> or snmp V3:"
                echo "  -u <authuser> -a <authproto> -A <authpass> -x <secproto> -X <secpass> -l <seclevel>"
                exit 3
        fi
}

function dbg_msg {
    if [ "$debug" ] ; then
        >&2 echo "DEBUG: $1"
    fi
}


function percent() {
    local total=$1
    local part=$2
    $bc -l <<< "scale=4; r( ($part / $total * 100), 0 )"
}

function convertsecs {
    local d
    local h
    local m
    local s
    ((d=${1}/86400))
    ((h=${1}%86400/3600))
    ((m=(${1}%3600)/60))
    ((s=${1}%60))
    printf "%3s days %02d:%02d:%02d\n" $d $h $m $s
}

function calc_state() {
    local value=$1;local warn=$2;local crit=$3;local rcode

    if [ $value -gt $crit ] ; then
        rcode=2
    elif [ $value -gt $warn ] ; then
        rcode=1
    else
        rcode=0
    fi
    echo $rcode
}

# take into account the current global return code
function calc_globalstate() {
    local value=$1;local warn=$2;local crit=$3;local rcode

    rcode=$( calc_state $value $warn $crit )

    if [ $rcode -le $glob_rcode ] ; then
        rcode=$glob_rcode
    else
        rcode=$rcode
    fi
    echo $rcode
}

function set_globalstate() {
    local rcode=$1

    if [ $rcode -le $glob_rcode ] ; then
        rcode=$glob_rcode
    else
        rcode=$rcode
    fi
    echo $rcode
}

function state_string() {
    local rcode=$1
    local string
    case $rcode in 
        0) string='(OK):' ;;
        1) string='(WARNING):' ;;
        2) string='(CRITICAL):' ;;
        3) string='(UNKNOWN):' ;;
    esac
    echo $string
}

function mode_string() {
    local mode=$1
    local string
    case $mode in 
        cpu) string='CPU' ;;
        license) string='Licenses' ;;
    esac
    echo $string
}

# generate human readable bytes
function hr_bytes() {
    local rawbyte=$1
    local bstr=Byte

    # more than 10 TB
    if [ $rawbyte -gt 10000000000000 ] ;then
        hrbyte="$(( $rawbyte>>40 )) T$bstr"

    # more than 10 GB
    elif [ $rawbyte -gt 10000000000 ] ;then
        hrbyte="$(( $rawbyte>>30 )) G$bstr"

    # more than 10 MB
    elif [ $rawbyte -gt 10000000 ] ;then
        hrbyte="$(( $rawbyte>>20 )) M$bstr"
    fi

    echo $hrbyte
}

function raid_byfilter() {
    # Print Out Data for Elements, filtered by Name
    # By default, select all elements

    local filter=$1

    for eName in ${!nameMap[@]}
    do
        if [[  "$eName" =~ $filter ]]
        then
            outElements+=(${nameMap[$eName]})
        fi
    done

    local loop_rcode=0
    local loop_state
    for element in  ${outElements[@]}
    do
        name=${snmpData[${baseOID}.${id[name]}.$element]}
        size_bytes=${snmpData[${baseOID}.${id[size]}.$element]}
        raid_status=${snmpData[${baseOID}.${id[status]}.$element]}

        # Check Status
        case $raid_status in
            '"Ready"')
                loop_rcode=0;;
            '"Degraded"')
                loop_rcode=1;;
        esac
        loop_state=$( state_string $loop_rcode )
        glob_rcode=$( set_globalstate $loop_rcode ) 

        # text output
        outmsg+="RAID $name: Capacity $(( size_bytes>>30 )) GB, Status $raid_status; "
        details+="$loop_state $name\n"
        details+="  Size:   $( hr_bytes $size_bytes )\n"
        details+="  Status: $raid_status\n\n"
    done
}

function get_snmp {
    #
    # Compose snmp command
    #
    if [ "$nobulk" ]; then walk=snmpwalk;  else walk=snmpbulkwalk; fi
    if [ -n "$authuser" ]; then snmpv=3; else snmpv=2c; fi

    snmpcmd="$walk -Onq -v $snmpv -t $tout -r 3 \
        $community $authuser $privproto $privpass $seclevel $authproto $authpass \
        $hostname  $baseOID"

    dbg_msg "debug snmpcmd: $snmpcmd"


    # First of all, get the SNMP-Data
    snmpResponse=$($snmpcmd 2>&1)
    snmpexit=$?

    dbg_msg "debugsnmpresponse: $snmpResponse"

    if [ $snmpexit -ne 0 ] ; then
        echo "(UNKNOWN): Problem fetching SNMP data."
        echo 
        echo "SNMP Output was: $snmpResponse"
        exit 3
    fi

    while read oid value
    do 
        snmpData[$oid]="$value"
    done <<< "$snmpResponse"
}

function process_snmp_index {
    #### building indexes
    #

    # build element index
    for key in ${!snmpData[@]} ; do
        if [[ $key == "$baseOID.${id[index]}"* ]] ; then
        elementIndex+=( ${snmpData[$key]} )
        fi
    done

    # build name map
    for element in  ${elementIndex[@]}
    do
        nameMap[${snmpData[${baseOID}.${id[name]}.$element]}]=${snmpData[${baseOID}.${id[index]}.$element]}
    done
    #
    #
    #### / building indexes
}

function process_snmp_noindex {
    #### building indexes
    #

    # build element list
    local element_counter=0
    for element in ${snmpData[@]} ; do
            elementList[$element_counter]=$element
            : $(( element_counter++ ))
    done
}

function idrac_status {
    local enum=$1
    local map=( dummy other unknown ok nonCritical critical nonRecoverable )
    if [ -z "${map[$enum]}" ] ; then
        dbg_msg "unknown state: $enum" ; exit 10
    fi
    echo "${map[$enum]}"
}

function idrac_state {
    local enum=$1
    local map=( dummy other unknown off on )
    if [ -z "${map[$enum]}" ] ; then
        dbg_msg "unknown state: $enum" ; exit 10
    fi
    echo "${map[$enum]}"
}

function check_globalstatus {
    local oid_names[1]='Global System Status'
    local oid_names[2]='LCD Status'
    local oid_names[3]='Storage Status'
    local oid_names[4]='Power State'
    local curOID
    local curStat
    local loop_status
    local loop_line

    details+="Details:\n"
    outmsg='iDARC overall status'
    for key in ${!oid_names[@]} ; do
        curOID="${baseOID}.$key.0"
        if [ $key -ne 4 ] ; then 
            # Other Status
            if [ ${snmpData[$curOID]} -lt 4 ]  ; then 
                loop_status=0
            elif [ ${snmpData[$curOID]} -eq 4 ] ; then
                loop_status=1
            elif [ ${snmpData[$curOID]} -gt 4 ] ; then
                loop_status=2
            fi
            curStat=`idrac_status ${snmpData[$curOID]}`

        else
            # Power State
            if [ ${snmpData[$curOID]} -eq 4 ]  ; then 
                loop_status=0
            elif [ ${snmpData[$curOID]} -lt 4 ] ; then
                loop_status=1
            fi
            curStat=`idrac_state ${snmpData[$curOID]}`
        fi
        loop_line=$( printf "%12s %-22s is %-15s" `state_string $loop_status` \
            "${oid_names[$key]}"  ${curStat^^} )
        details+="  $loop_line\n"
        glob_rcode=$( set_globalstate $loop_status ) 
    done
}

function check_uptime {
    uptime_sec=${snmpData[$baseOID]}
    outmsg="Chassis Uptime `convertsecs $uptime_sec`"
    perfdata="uptime_sec=${uptime_sec}s"
}

#
# MAIN
#

#
# set default values
#
mode=${mode:=globalstatus}
filter=${filter:=.}
tout=${tout:=20}

check_arguments
# 
# precission calculator 'bc' compat. check
#
if [ -x /usr/local/bin/bc ]; then 
    bc=/usr/local/bin/bc
elif [ -x /usr/bin/bc ] ; then
    bc=/usr/bin/bc
fi

case $mode in
    globalstatus)
        baseOID='.1.3.6.1.4.1.674.10892.5.2'
        get_snmp
        process_snmp_noindex
        check_globalstatus
    ;;

    uptime)
        baseOID='.1.3.6.1.4.1.674.10892.5.2.5.0'
        get_snmp
        check_uptime
    ;;
    
    *)
        echo "(UNKNOWN): mode '-m $mode' not known" ; exit 3 ;;
esac


#
# Tell monitoring system what we found out
#
echo -en "$( state_string $glob_rcode ) $outmsg"
if [ -n "$details" ] ; then echo -en "\n\n$details" ; fi
if [ -n "$perfdata" ] ; then echo -en "|$perfdata" ; fi
echo

exit $glob_rcode


#vim: set ts=4 expandtab sw=4
