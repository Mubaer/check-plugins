#!/usr/bin/env bash

# Check HP Comware IRF Stacking Ports
#
# Author: msander
#
# Version: 0.1  2023-10-11
#   first test version
#
# Version: 1.0  2024-02-21
#   first prod version
#

# Define Vars
declare -A snmpData

glob_rcode=0

#
# CLI Parsing
#

OPTERR=1
while getopts "H:C:u:x:X:a:A:l:w:c:m:f:F:t:Bhd" OPTION ; do
    case "${OPTION}" in
        H) hostname=${OPTARG}       ;;
        C) community="-c ${OPTARG}" ;;
        u) authuser="-u ${OPTARG}"  ;;
        a) authproto="-a ${OPTARG}" ;;
        A) authpass="-A ${OPTARG}"  ;;
        x) privproto="-x ${OPTARG}" ;;
        X) privpass="-X ${OPTARG}"  ;;
        l) seclevel="-l ${OPTARG}"  ;;
        t) tout=${OPTARG}           ;;
        B) nobulk=1                 ;;
        h) helpme=1                 ;;
        d) debug=1                  ;;
    esac
done

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Load library functions
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

callpath="$(dirname "$0")"
libdir="${callpath}/../lib"

source $libdir/generic_plugin.shlib
source $libdir/generic_snmp.shlib

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local functions
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

function get_snmp {
    #
    # Compose snmp command
    #
    if [ "$nobulk" ]; then walk=snmpwalk;  else walk=snmpbulkwalk; fi
    if [ -n "$authuser" ]; then snmpv=3; else snmpv=2c; fi

    snmpcmd="$walk -Onqt -v $snmpv -t $tout -r 3 \
        $community $authuser $privproto $privpass $seclevel $authproto $authpass \
        $hostname  $baseOID"

    dbg_msg "debug snmpcmd: $snmpcmd"


    # First of all, get the SNMP-Data
    snmpResponse=$($snmpcmd 2>&1)
    snmpexit=$?

    dbg_msg "debugsnmpresponse: $snmpResponse"

    if [ $snmpexit -ne 0 ] ; then
        echo "(UNKNOWN): Problem fetching SNMP data."
        echo 
        echo "SNMP Output was: $snmpResponse"
        exit 3
    fi

    while read oid value
    do 
        snmpData[$oid]="$value"
    done <<< "$snmpResponse"
}

function map_status {
    local state=$1
    case $state in
        1)  string=ok       ;;
        2)  string=down     ;;
        3)  string=silent   ;;
        4)  string=disabled ;;
    esac
    echo $string
}
function check_irf_status {
    for oid in ${!snmpData[@]} ; do
        #echo "OID is $oid, value is ${snmpData[$oid]}"
        if [ "${snmpData[$oid]}" -eq 2 ] ;then
            loop_status='[crit]'
            outmsg='IRF-Stack: one or more ports are DOWN'
            glob_rcode=$( set_globalstate 2 )
        else
            loop_status='[ok]'
            outmsg='IRF-Stack: all ports are UP'
        fi
        # Extract Member and Port Info from OID
        loop_suboid=${oid#${baseOID}.}
        loop_member=${loop_suboid%.?}
        loop_irfport=${loop_suboid#?.}
        loop_irfstatus=$( map_status ${snmpData[$oid]} )
        details+="$loop_status Stack Member $loop_member, IRF-Port $loop_irfport: ${loop_irfstatus}\n"
    done
}

#
# MAIN
#

#
# set default values
#
mode=${mode:=snmpv2}
tout=${tout:=20}

check_arguments

baseOID='.1.3.6.1.4.1.25506.2.91.4.1.3'
get_snmp
check_irf_status

#
# Tell monitoring system what we found out
#
echo -en "$( state_string $glob_rcode ) $outmsg"
if [ -n "$details" ] ; then echo -en "\n\n$details" ; fi
if [ -n "$perfdata" ] ; then echo -en "|$perfdata" ; fi
echo

exit $glob_rcode

#vim: set ts=4 expandtab sw=4
