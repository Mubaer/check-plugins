#!/usr/bin/env bash

# This plugin checks the PSU of various device types
#
# Author: Xin Qu
#
# Version: 0.1 2024-12-20
#	First test version
#	Support for aruba cx
#

# Define Vars
declare -A snmpData
declare -A snmpUnit
declare -A id
declare -A nameMap

glob_rcode=0

#
# CLI Parsing
#

OPTERR=1
while getopts "H:C:u:x:X:a:A:l:w:c:m:f:F:t:Bhd" OPTION ; do
	case "${OPTION}" in
		H) hostname=${OPTARG}		;;
		C) community="-c ${OPTARG}" ;;
		u) authuser="-u ${OPTARG}"	;;
		a) authproto="-a ${OPTARG}" ;;
		A) authpass="-A ${OPTARG}"	;;
		x) privproto="-x ${OPTARG}" ;;
		X) privpass="-X ${OPTARG}"	;;
		l) seclevel="-l ${OPTARG}"	;;
		w) warn=${OPTARG}			;;
		c) crit=${OPTARG}			;;
		m) mode=${OPTARG}			;;
		f) filter=${OPTARG}			;;
		F) neg_filter=${OPTARG}		;;
		t) tout=${OPTARG}			;;
		B) nobulk=1					;;
		h) helpme=1					;;
		d) debug=1					;;
	esac
done

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Load library functions
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

callpath="$(dirname "$0")"
libdir="${callpath}/../lib"

source $libdir/generic_plugin.shlib
source $libdir/generic_snmp.shlib
source $libdir/convert_and_calc.shlib

#######
# Functions
#######

function status_stringmap_arubacx {
	local numState=$1

	local -a map
	map=( \
		[1]='ok' \
		[2]='faultAbsent' \
		[3]='faultInput' \
		[4]='faultOutput' \
		[5]='faultPOE' \
		[6]='faultNoRecov' \
		[7]='alert' \
		[8]='unknown' \
		[9]='unsupported' \
		[10]='warning' \
		[11]='init' \
		[12]='empty' \
		[13]='faultAirflow' \
		[14]='faultRedundancy' \
	)


	echo "${map[$numState]}"
}

function status_errormap_arubacx {
	local numState=$1

	local -a map
	map=( \
		[1]=0 \
		[2]=0 \
		[3]=2 \
		[4]=2 \
		[5]=2 \
		[6]=2 \
		[7]=2 \
		[8]=3 \
		[9]=0 \
		[10]=1 \
		[11]=0 \
		[12]=0 \
		[13]=2 \
		[14]=1 \
	)

	echo "${map[$numState]}"
}

function psu_table {
	local filter=$1

	outmsg='PSU Check: '
	for eName in "${!nameMap[@]}"
    do
        if [[  "$eName" =~ $filter ]]
        then
			outElements+=(${nameMap[$eName]})
        fi
    done

	local name
	local productName
	local psuState
	local psuStateString
	# State is OK in case we don't get state information from device
	local stateByState=0
	local stateByPower
	local maxPower
	local curPower
	local relPower
	local numFailures
	local detail_line
	local loopState=0
	local loopStateString

    for element in  ${outElements[@]}
    do
        name=${snmpData[${baseOID}.${id[name]}.$element]}
		# remove quotes
		name=${name//\"/}
		# quick and dirty fix: remove trailing space (real fix above, but requires qnap testing)
		name=${name/% /}

		outmsg+="$name:"
		detail_line="$name:\n"

		# enter state handling when defined
		if [ -n "${id[state]}" ] ; then
			psuState=${snmpData[${baseOID}.${id[state]}.$element]}
			psuStateString=$( status_stringmap_$mode $psuState )

			stateByState=$( status_errormap_$mode $psuState )
			stateByStateString=$( state_string $stateByState )

			outmsg+=", State: $psuStateString"
			detail_line+="\tState: $psuStateString\n"
			# remember for later
		fi

		# enter power comsumptin handling when defined
		if [ -n "${id[maxpower]}" -a -n "${id[curpower]}" ] ; then
			maxPower=${snmpData[${baseOID}.${id[maxpower]}.$element]}
			curPower=${snmpData[${baseOID}.${id[curpower]}.$element]}

			# only PSUs with maxPower != 0
			if [ $maxPower -ne 0 ]  ; then
				relPower=$( percent $maxPower $curPower )
				outmsg+=" Power ${relPower}%"
				detail_line+="\tPower: ${curPower}W of ${maxPower}W (${relPower}%)\n"
			fi
			# only calc thresholds when a stateByState is "OK" (0) AND maxPower != 0
			if [ "$stateByState" -eq 0 -a $maxPower -ne 0 ]  ; then
				if [ -n "$crit" -a -n "$warn" ] ; then
					stateByPower=$( calc_state $relPower $warn $crit )
				fi
			else
				stateByPower=0
			fi
			# perfdata only for maxPower != 0	
			if [ $maxPower -ne 0 ]  ; then
				perfdata+="$name=$relPower;$warn;$crit "
			fi
		fi


		if [ -n "${id[serial]}" ] ;then
			local psuSerial=${snmpData[${baseOID}.${id[serial]}.$element]}
			detail_line+="\tS/N: $psuSerial\n"
		fi
		if [ -n "${id[prodname]}" ] ;then
			local psuProd=${snmpData[${baseOID}.${id[prodname]}.$element]}
			detail_line+="\tProduct: $psuProd\n"
		fi



		# Status of power comsumptions 'wins'
		if [ -n "$stateByPower" ] ; then
			if [  "$stateByPower" -gt "$stateByState" ] ;  then
				loopState=$stateByPower
			else
				loopState=$stateByState
			fi
		fi

		loopStateString=$( state_string $loopState n n )
		# Prepend PSU status to line
		detail_line="$loopStateString $detail_line"

		# update global state
		glob_rcode=$( set_globalstate $loopState )
		# merge everything together
		outmsg+="; "
		details+="$detail_line\n"
	done
}

#
# MAIN
#

#
# set default values
#
mode=${mode:=qnap}
filter=${filter:=.}
tout=${tout:=20}

check_snmp_args
check_threshold_args

case $mode in
	arubacx)
		baseOID='.1.3.6.1.4.1.47196.4.1.1.3.11.2.1.1'
		id[name]=3
		id[curpower]=7
		id[maxpower]=8
		id[state]=11
		id[prodname]=5
		id[serial]=6
		get_snmp_lib
		test_errors 'PSUs: ' 'PSUs'
		process_snmp_namedindex_flex
		psu_table .
		;;
	*)
		echo "(UNKNOWN): mode '-m $mode' not known" ; exit 3 ;;
esac


#
# Tell monitoring system what we found out
#
trigger_exit
