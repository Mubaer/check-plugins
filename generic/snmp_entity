#!/usr/bin/env bash
#
# This plugin checks various (hardware) entities found in:
#
# General:         ENTITY-MIB
# Hewlett Packard: HH3C-ENTITY-EXT-MIB
# Cisco:           CISCO-ENTITY-VENDORTYPE-OID-MIB
#
# Author: Xin Qu
#
# Version: 1.2.1 2024-12-20
#	finalized ENTITY-MIB information
#
# Version: 1.2 2024-12-20
#	added support for ENTITY-MIB information
#	(introduced for Aruba CX)
#
# Version: 1.1 2024-03-20
#	added support for cisco devices (fan, psu)
#
# Version: 1.0 2024-03-18
#	modified check to a general check for HP entities, taking entity classes
#	from command line
#
# Version: 0.2 2024-03-18
#	Make script more usable in a generic way
#	
# Version: 0.1 2024-03-15
#	First test version
#
#

# Define Vars
declare -A snmpData
declare -A snmpUnit
declare -A id
declare -A nameMap

glob_rcode=0

#
# CLI Parsing
#

OPTERR=1
while getopts "H:C:u:x:X:a:A:l:w:c:k:m:n:f:F:t:Bhd" OPTION ; do
	case "${OPTION}" in
		H) hostname=${OPTARG};;
		C) community="-c ${OPTARG}";;
		u) authuser="-u ${OPTARG}";;
		a) authproto="-a ${OPTARG}";;
		A) authpass="-A ${OPTARG}";;
		x) privproto="-x ${OPTARG}";;
		X) privpass="-X ${OPTARG}";;
		l) seclevel="-l ${OPTARG}";;
		w) warn=${OPTARG};;
		c) crit=${OPTARG};;
		m) mode=${OPTARG};;
		n) checkName=${OPTARG};;
		k) classList=${OPTARG};;
		f) filter=${OPTARG};;
		F) neg_filter=${OPTARG};;
		t) tout=${OPTARG};;
		B) nobulk=1;;
		h) helpme=1;;
		d) debug=1;;
	esac
done

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Load library functions
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

callpath="$(dirname "$0")"
libdir="${callpath}/../lib"

source $libdir/generic_plugin.shlib
source $libdir/generic_snmp.shlib
source $libdir/convert_and_calc.shlib

#######
# Functions
#######

function read_entity_mib {
	# for this kind of check, the user can name the whole
	# thing using -n. Set a default here
	: ${checkName:=Physical Check: }
	outmsg="$checkName"

	# read whole entPhysicalTable one time
	baseOID='.1.3.6.1.2.1.47.1.1.1.1'
	id[name]=7
	get_snmp_lib nounit
	process_snmp_namedindex
}

function filter_entity_byname {

	local filter=$1
	local idx
	local eName
	local nameOID

	for idx in "${elementList[@]}"
    do
		nameOID="${baseOID}.${id[name]}.$idx"
		eNamePart1=$snmpData[$nameOID]
		if [ -z "${snmpUnit[$nameOID]}" ] ; then
			eName=${snmpData[$nameOID]}
		else
			eName="${snmpData[$nameOID]} ${snmpUnit[$nameOID]}"
        fi
		if [[ "$eName" =~ $filter ]] ;then
			dbg_msg "Adding $eName to index $idx"
			outElements+=( $idx )
		fi
    done
}

function filter_entity_byclass {

	local classLeaf=$1
	local filter=$2
	local idx
	local class

	# reset outElements to allow multiple calls of this function
	outElements=()
	dbg_msg "out elements: ${outElements[*]}"

	for idx in "${elementList[@]}"
    do
		classOID="${baseOID}.$classLeaf.$idx"
		class=${snmpData[$classOID]}
		if [[ "$class" == "$filter" ]] ;then
			dbg_msg "Adding $class to index $idx"
			outElements+=( $idx )
		fi
    done
}

function check_hp_element_status {
	# Requires "filter_entity" to run before
	local errorStatusOID=$1
	local outPrefix=$2
	local element
	local eStatus
	local eName
	local loop_rcode
	local loop_sstring

	outmsg+="$outPrefix "
	for element in ${outElements[@]} ; do

		# get element name
		if [ -z "${snmpUnit[$baseOID.${id[name]}.$element]}" ] ;then
			eName="${snmpData[$baseOID.${id[name]}.$element]}"
		else
			eName="${snmpData[$baseOID.${id[name]}.$element]} ${snmpUnit[$baseOID.${id[name]}.$element]}"
		fi
		# remove quotes
		eName=${eName//\"/}
		
		# get error status
		get_snmp $errorStatusOID.$element
		eStatus=$( map_hh3cEntityExtErrorStatus ${snmpData[$errorStatusOID.$element]} )
		loop_rcode=$( rate_hh3cEntityExtErrorStatus ${snmpData[$errorStatusOID.$element]} )
		loop_sstring=$( state_string $loop_rcode y )

		# Output & set exit code
		outmsg+="$eName: $eStatus; "
		details+="$loop_sstring $eName: $eStatus; "
		details+="\n"

		glob_rcode=$( set_globalstate $loop_rcode )
	done
}


function map_hh3cEntityExtErrorStatus {
	local int=$1

	local -A error_map=( \
		[1]='notSupported' \
		[2]='normal' \
		[3]='postFailure' \
		[4]='entityAbsent' \
		[11]='poeError' \
		[21]='stackError' \
		[22]='stackPortBlocked' \
		[23]='stackPortFailed' \
		[31]='sfpRecvError' \
		[32]='sfpSendError' \
		[33]='sfpBothError' \
		[41]='fanError' \
		[51]='psuError' \
		[61]='rpsError' \
		[71]='moduleFaulty' \
		[81]='sensorError' \
		[91]='hardwareFaulty' \
	)
	echo ${error_map[$int]}
}

function rate_hh3cEntityExtErrorStatus {
	local int=$1

	local -A error_map=( [1]=0 [2]=0 [3]=2 [4]=0 [11]=2 [21]=2 [22]=2 [23]=2 \
		[31]=2 [32]=2 [33]=2 [41]=2 [51]=2 [61]=2 [71]=2 [81]=2 [91]=2 )
	echo ${error_map[$int]}
}

function map_className {
	local in=$1
	local mode=$2
	local -A class_map
	local -A class_Rmap
	: ${mode:=forward}

	class_map=( \
		[2]='unknown'      \
		[3]='Chassis'      \
		[4]='Backpanel'    \
		[5]='Container'    \
		[6]='Power Supply' \
		[7]='Fan'          \
		[8]='Sensor'       \
		[9]='Module'       \
		[10]='Port'        \
		[11]='Stack'       \
		[12]='CPU'         \
		[13]='Energy'      \
		[14]='Battery'     \
	)

	class_Rmap=( \
		[other]=1     \
		[unknown]=2   \
		[chassis]=3   \
		[container]=5 \
		[psu]=6       \
		[fan]=7       \
		[sensor]=8    \
		[module]=9    \
		[port]=10     \
		[stack]=11    \
	)

	case $mode in
		forward)
			echo "${class_map[$in]}" ;;
		reverse)
			echo "${class_Rmap[$in]}";;
		listCLIValues)
			echo "${!class_Rmap[@]}";;
	esac
}

function check_cisco_element_status {
	local extOID='.1.3.6.1.4.1.9.9.117.1'  # cefcMIBObjects

	local class=$1
	local outPrefix=$2
	local classLeaf=$( map_cisco_errorLeaf $class )
	local fetchOID="$extOID.$classLeaf"
	local numStatus
	local descStatus
	local loopRCODE

	outmsg+="$outPrefix "
	for element in ${outElements[@]} ; do
		get_snmp $fetchOID.$element
		numStatus=${snmpData[$fetchOID.$element]}
		dbg_msg "numStatus: $numStatus"
		descStatus=$( map_cisco_error_status $class $numStatus )
		loopRCODE=$( rate_ciso_error $class $numStatus )
		dbg_msg "looprcode: $loopRCODE"
		glob_rcode=$( set_globalstate $loopRCODE )

		# get element name
		if [ -z "${snmpUnit[$baseOID.${id[name]}.$element]}" ] ;then
			eName="${snmpData[$baseOID.${id[name]}.$element]}"
		else
			eName="${snmpData[$baseOID.${id[name]}.$element]} ${snmpUnit[$baseOID.${id[name]}.$element]}"
		fi
		# remove quotes
		eName=${eName//\"/}

		statusString=$( state_string $loopRCODE y )
		outmsg+="$eName: $descStatus; "
		details+="$statusString  $eName: $descStatus\n"
	done
}

function get_entitiy_info {
	local class=$1
	local outPrefix=$2
	local key
	local keyorder
	local ename
	local -A n2oid

	n2oid=( \
		[Name]=7       \
		[Descr.]=2      \
		#[vendortype]=3 \
		[HW-Rev.]=8    \
		[FW-Rev.]=9    \
		[SW-Rev.]=10   \
		[S/N]=11    \
		[Model]=13     \
	)

	keyorder=( Descr. HW-Rev. FW-Rev. SW-Rev. S/N Model)

	for element in ${outElements[@]} ; do
		# remove quotes from 'Name'
		details+="${snmpData[$baseOID.${n2oid[Name]}.$element]//\"/}:\n"
		for key in ${keyorder[@]} ; do
			details+="\t$key: ${snmpData[$baseOID.${n2oid[$key]}.$element]}\n"
		done
		details+="\n"
	done

}

function map_cisco_errorLeaf {
	local in=$1
	local -A errorMap

	errorMap=( [6]='1.2.1.2' [7]='4.1.1.1' )

	echo "${errorMap[$in]}"
}

function map_cisco_error_status {
	local class=$1
	local numStat=$2
	declare -A fanStatus
	fanStatus=( [1]='unknown' [2]='up' [3]='down' [4]='waring' )
	declare -A psuStatus
	psuStatus=( \
		[1]='offEnvOther' \
		[2]='on' \
		[3]='offAdmin' \
		[4]='offDenied' \
		[5]='offEnvPower' \
		[6]='offEnvTemp' \
		[7]='offEnvFan' \
		[8]='failed' \
		[9]='onButFanFail' \
		[10]='offCooling' \
		[11]='offConnectorRating' \
		[12]='onButInlinePowerFail' \
	)
	case $class in
		6)
			echo ${psuStatus[$numStat]} ;;
		7)
			echo ${fanStatus[$numStat]} ;;
	esac
}

function rate_ciso_error {
	local class=$1
	local int=$2

	local -A psuMap=( [1]=0 [2]=0 [3]=1 [4]=1 [5]=1 \
		[6]=1 [7]=1 [8]=2 [9]=2 [10]=1 [11]=1 [12]=2 )
	local -A fanMap=( [1]=3 [2]=0 [3]=2 [4]=1 )

	case $class in
		6)
			echo ${psuMap[$int]} ;;
		7)
			echo ${fanMap[$int]} ;;
	esac
}

#
# MAIN
#

#
# set default values
#
mode=${mode:=hp}
filter=${filter:=.}
tout=${tout:=20}

# Check Arguments
# - argument 'classes' for 'multimode'
#
if [ -z "$classList" ] ; then
	outmsg="Mode '-m multi' requires a list of entity class names, e.g. '-k psu,fan'\n\n"
	outmsg+="List of supported class values:\n"

	for value in $( map_className 0 listCLIValues ) ; do
		outmsg+="- $value\n"
	done

	glob_rcode=3
	trigger_exit

else
	# convert class list to array
	classNameArray=${classList//,/ }

	# convert to numeric SNMP values
	declare -a classArray
	for class in ${classNameArray[@]} ; do
		classArray+=( $( map_className $class reverse ) )
	done
fi

check_snmp_args
check_threshold_args

case $mode in
	hp)
		read_entity_mib
		# Proceed at hh3cEntityExtStateTable
		extOID='.1.3.6.1.4.1.25506.2.6.1.1.1.1'
		errorStatusOID="${extOID}.19"

		for class in ${classArray[@]} ; do
			filter_entity_byclass 5 $class
			className=$( map_className $class )
			check_hp_element_status $errorStatusOID "[$className] "
		done
		;;
	cisco)
		read_entity_mib
		# Proceed at  ciscoEntityFRUControlMIB
		extOID=' .1.3.6.1.4.1.9.9.117.1'  # cefcMIBObjects

		for class in ${classArray[@]} ; do
			filter_entity_byclass 5 $class
			className=$( map_className $class )
			check_cisco_element_status $class "[$className] "
		done
		;;
	arubacx)
		read_entity_mib
		for class in ${classArray[@]} ; do
			filter_entity_byclass 5 $class
			className=$( map_className $class )
			get_entitiy_info $class "[$className] "
		done
		;;
	*)
		echo "(UNKNOWN): mode '-m $mode' not known" ; exit 3 ;;
esac


#
# Tell monitoring system what we found out
#
trigger_exit
