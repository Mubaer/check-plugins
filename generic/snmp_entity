#!/usr/bin/env bash

# This plugin checks various (hardware) entities of
# ENTITY-MIB, HH3C-ENTITY-EXT-MIB
#
# Author: Xin Qu
#
# Version: 0.2 2024-03-18
#	Make script more usable in a generic way
#	
# Version: 0.1 2024-03-15
#	First test version
#
#

# Define Vars
declare -A snmpData
declare -A snmpUnit
declare -A id
declare -A nameMap

glob_rcode=0

#
# CLI Parsing
#

OPTERR=1
while getopts "H:C:u:x:X:a:A:l:w:c:k:m:n:f:F:t:Bhd" OPTION ; do
	case "${OPTION}" in
		H) hostname=${OPTARG}		;;
		C) community="-c ${OPTARG}" ;;
		u) authuser="-u ${OPTARG}"	;;
		a) authproto="-a ${OPTARG}" ;;
		A) authpass="-A ${OPTARG}"	;;
		x) privproto="-x ${OPTARG}" ;;
		X) privpass="-X ${OPTARG}"	;;
		l) seclevel="-l ${OPTARG}"	;;
		w) warn=${OPTARG}			;;
		c) crit=${OPTARG}			;;
		m) mode=${OPTARG}			;;
		n) checkName=${OPTARG}		;;
		k) classList=${OPTARG}		;;
		f) filter=${OPTARG}			;;
		F) neg_filter=${OPTARG}		;;
		t) tout=${OPTARG}			;;
		B) nobulk=1					;;
		h) helpme=1					;;
		d) debug=1					;;
	esac
done

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Load library functions
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

callpath="$(dirname "$0")"
libdir="${callpath}/../lib"

source $libdir/generic_plugin.shlib
source $libdir/generic_snmp.shlib
source $libdir/convert_and_calc.shlib

#######
# Functions
#######

function filter_entity_byname {

	local filter=$1
	local idx
	local eName
	local nameOID

	for idx in "${elementList[@]}"
    do
		nameOID="${baseOID}.${id[name]}.$idx"
		eNamePart1=$snmpData[$nameOID]
		if [ -z "${snmpUnit[$nameOID]}" ] ; then
			eName=${snmpData[$nameOID]}
		else
			eName="${snmpData[$nameOID]} ${snmpUnit[$nameOID]}"
        fi
		if [[ "$eName" =~ $filter ]] ;then
			dbg_msg "Adding $eName to index $idx"
			outElements+=( $idx )
		fi
    done
}

function filter_entity_byclass {

	local classLeaf=$1
	local filter=$2
	local idx
	local class

	# reset outElements to allow multiple calls of this function
	outElements=()
	dbg_msg "out elements: ${outElements[*]}"

	for idx in "${elementList[@]}"
    do
		classOID="${baseOID}.$classLeaf.$idx"
		class=${snmpData[$classOID]}
		if [[ "$class" == "$filter" ]] ;then
			dbg_msg "Adding $class to index $idx"
			outElements+=( $idx )
		fi
    done
}

function check_element_error_status {
	# Requires "filter_entity" to run before
	local errorStatusOID=$1
	local outPrefix=$2
	local element
	local eStatus
	local eName
	local loop_rcode
	local loop_sstring

	outmsg+="$outPrefix "
	for element in ${outElements[@]} ; do

		# get element name
		eName1=${snmpData[$baseOID.${id[name]}.$element]}
		if [ -z "${snmpUnit[$baseOID.${id[name]}.$element]}" ] ;then
			eName="${snmpData[$baseOID.${id[name]}.$element]}"
		else
			eName="${snmpData[$baseOID.${id[name]}.$element]} ${snmpUnit[$baseOID.${id[name]}.$element]}"
		fi
		# remove quotes
		eName=${eName//\"/}
		
		# get error status
		get_snmp $errorStatusOID.$element
		eStatus=$( map_hh3cEntityExtErrorStatus ${snmpData[$errorStatusOID.$element]} )
		loop_rcode=$( rate_hh3cEntityExtErrorStatus ${snmpData[$errorStatusOID.$element]} )
		loop_sstring=$( state_string $loop_rcode y )

		# Output & set exit code
		outmsg+="$eName: $eStatus; "
		details+="$loop_sstring $eName: $eStatus; "
		details+="\n"

		glob_rcode=$( set_globalstate $loop_rcode )
	done
}


function map_hh3cEntityExtErrorStatus {
	local int=$1

	local -A error_map=( \
		[1]='notSupported' \
		[2]='normal' \
		[3]='postFailure' \
		[4]='entityAbsent' \
		[11]='poeError' \
		[21]='stackError' \
		[22]='stackPortBlocked' \
		[23]='stackPortFailed' \
		[31]='sfpRecvError' \
		[32]='sfpSendError' \
		[33]='sfpBothError' \
		[41]='fanError' \
		[51]='psuError' \
		[61]='rpsError' \
		[71]='moduleFaulty' \
		[81]='sensorError' \
		[91]='hardwareFaulty' \
	)
	echo ${error_map[$int]}
}

function rate_hh3cEntityExtErrorStatus {
	local int=$1

	local -A error_map=( [1]=0 [2]=0 [3]=2 [4]=0 [11]=2 [21]=2 [22]=2 [23]=2 \
		[31]=2 [32]=2 [33]=2 [41]=2 [51]=2 [61]=2 [71]=2 [81]=2 [91]=2 )
	echo ${error_map[$int]}
}

function map_className {
	local in=$1
	local mode=$2
	local -A class_map
	local -A class_Rmap
	: ${mode:=forward}

	class_map=( \
		[2]='unknown'      \
		[3]='Chassis'      \
		[4]='Backpanel'    \
		[5]='Container'    \
		[6]='Power Supply' \
		[7]='Fan'          \
		[8]='Sensor'       \
		[9]='Module'       \
		[10]='Port'        \
		[11]='Stack'       \
	)

	class_Rmap=( \
		[container]=5 \
		[psu]=6       \
		[fan]=7       \
		[Sensor]=8    \
		[module]=9    \
		[port]=10     \
		[stack]=11    \
	)

	case $mode in
		forward)
			echo "${class_map[$in]}" ;;
		reverse)
			echo "${class_Rmap[$in]}";;
		listCLIValues)
			echo "${!class_Rmap[@]}";;
	esac
}
	


#
# MAIN
#

#
# set default values
#
mode=${mode:=hp}
filter=${filter:=.}
tout=${tout:=20}

# Check Arguments
# - argument 'classes' for 'multimode'
#
if [ -z "$classList" ] ; then
	outmsg="Mode '-m multi' requires a list of entity class names, e.g. '-k psu,fan'\n\n"
	outmsg+="List of supported class values:\n"

	for value in $( map_className 0 listCLIValues ) ; do
		outmsg+="- $value\n"
	done

	glob_rcode=3
	trigger_exit

else
	# convert class list to array
	classNameArray=${classList//,/ }

	# convert to numeric SNMP values
	declare -a classArray
	for class in ${classNameArray[@]} ; do
		classArray+=( $( map_className $class reverse ) )
	done
fi

check_snmp_args
check_threshold_args

case $mode in
	hp)
		# for this kind of check, the user can name the whole
		# thing using -n. Set a default here
		: ${checkName:=Physical Check: }
		outmsg="$checkName"

		# read whole entPhysicalTable one time
		baseOID='.1.3.6.1.2.1.47.1.1.1.1'
		id[name]=7
		get_bulk_snmp
		process_snmp_namedindex

		# Switch to hh3cEntityExtStateTable
		extOID='.1.3.6.1.4.1.25506.2.6.1.1.1.1'
		errorStatusOID="${extOID}.19"

		classes=( 7 6 )
		for class in ${classArray[@]} ; do
			filter_entity_byclass 5 $class
			className=$( map_className $class )
			check_element_error_status $errorStatusOID "[$className] "
		done
		;;
	*)
		echo "(UNKNOWN): mode '-m $mode' not known" ; exit 3 ;;
esac


#
# Tell monitoring system what we found out
#
trigger_exit
