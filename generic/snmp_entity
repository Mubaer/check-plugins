#!/usr/bin/env bash

# This plugin checks various (hardware) entities of
# ENTITY-MIB, HH3C-ENTITY-EXT-MIB
#
# Author: Xin Qu
#
# Version: 0.2 2024-03-18
#	Make script more usable in a generic way
#	
# Version: 0.1 2024-03-15
#	First test version
#
#

# Define Vars
declare -A snmpData
declare -A snmpUnit
declare -A id
declare -A nameMap

glob_rcode=0

#
# CLI Parsing
#

OPTERR=1
while getopts "H:C:u:x:X:a:A:l:w:c:m:f:F:t:Bhd" OPTION ; do
	case "${OPTION}" in
		H) hostname=${OPTARG}		;;
		C) community="-c ${OPTARG}" ;;
		u) authuser="-u ${OPTARG}"	;;
		a) authproto="-a ${OPTARG}" ;;
		A) authpass="-A ${OPTARG}"	;;
		x) privproto="-x ${OPTARG}" ;;
		X) privpass="-X ${OPTARG}"	;;
		l) seclevel="-l ${OPTARG}"	;;
		w) warn=${OPTARG}			;;
		c) crit=${OPTARG}			;;
		m) mode=${OPTARG}			;;
		n) checkName=${OPTARG}		;;
		C) classList=${OPTARG}		;;
		f) filter=${OPTARG}			;;
		F) neg_filter=${OPTARG}		;;
		t) tout=${OPTARG}			;;
		B) nobulk=1					;;
		h) helpme=1					;;
		d) debug=1					;;
	esac
done

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Load library functions
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

callpath="$(dirname "$0")"
libdir="${callpath}/../lib"

source $libdir/generic_plugin.shlib
source $libdir/generic_snmp.shlib
source $libdir/convert_and_calc.shlib

#######
# Functions
#######

function filter_entity_byname {

	local filter=$1
	local idx
	local eName
	local nameOID

	for idx in "${elementList[@]}"
    do
		nameOID="${baseOID}.${id[name]}.$idx"
		eNamePart1=$snmpData[$nameOID]
		if [ -z "${snmpUnit[$nameOID]}" ] ; then
			eName=${snmpData[$nameOID]}
		else
			eName="${snmpData[$nameOID]} ${snmpUnit[$nameOID]}"
        fi
		if [[ "$eName" =~ $filter ]] ;then
			dbg_msg "Adding $eName to index $idx"
			outElements+=( $idx )
		fi
    done
}

function filter_entity_byclass {

	local classLeaf=$1
	local filter=$2
	local idx
	local class

	# reset outElements to allow multiple calls of this function
	outElements=()
	dbg_msg "out elements: ${outElements[*]}"

	for idx in "${elementList[@]}"
    do
		classOID="${baseOID}.$classLeaf.$idx"
		class=${snmpData[$classOID]}
		if [[ "$class" == "$filter" ]] ;then
			dbg_msg "Adding $class to index $idx"
			outElements+=( $idx )
		fi
    done
}

function check_element_error_status {
	# Requires "filter_entity" to run before
	local errorStatusOID=$1
	local outPrefix=$2
	local element
	local eStatus
	local eName
	local loop_rcode
	local loop_sstring

	outmsg+="$outPrefix "
	for element in ${outElements[@]} ; do

		# get element name
		eName1=${snmpData[$baseOID.${id[name]}.$element]}
		if [ -z "${snmpUnit[$baseOID.${id[name]}.$element]}" ] ;then
			eName="${snmpData[$baseOID.${id[name]}.$element]}"
		else
			eName="${snmpData[$baseOID.${id[name]}.$element]} ${snmpUnit[$baseOID.${id[name]}.$element]}"
		fi
		# remove quotes
		eName=${eName//\"/}
		
		# get error status
		get_snmp $errorStatusOID.$element
		eStatus=$( map_hh3cEntityExtErrorStatus ${snmpData[$errorStatusOID.$element]} )
		loop_rcode=$( rate_hh3cEntityExtErrorStatus ${snmpData[$errorStatusOID.$element]} )
		loop_sstring=$( state_string $loop_rcode y )

		# Output & set exit code
		outmsg+="$eName: $eStatus; "
		details+="$loop_sstring $eName: $eStatus; "
		details+="\n"

		glob_rcode=$( set_globalstate $loop_rcode )
	done
}


function map_hh3cEntityExtErrorStatus {
	local int=$1

	local -A error_map=( \
		[1]='notSupported' \
		[2]='normal' \
		[3]='postFailure' \
		[4]='entityAbsent' \
		[11]='poeError' \
		[21]='stackError' \
		[22]='stackPortBlocked' \
		[23]='stackPortFailed' \
		[31]='sfpRecvError' \
		[32]='sfpSendError' \
		[33]='sfpBothError' \
		[41]='fanError' \
		[51]='psuError' \
		[61]='rpsError' \
		[71]='moduleFaulty' \
		[81]='sensorError' \
		[91]='hardwareFaulty' \
	)
	echo ${error_map[$int]}
}

function rate_hh3cEntityExtErrorStatus {
	local int=$1

	local -A error_map=( [1]=0 [2]=0 [3]=2 [4]=0 [11]=2 [21]=2 [22]=2 [23]=2 \
		[31]=2 [32]=2 [33]=2 [41]=2 [51]=2 [61]=2 [71]=2 [81]=2 [91]=2 )
	echo ${error_map[$int]}
}

function map_className {
	local int=$1

	local -A class_map=( \
	[2]='unknown' \
	[3]='Chassis' \
	[4]='Backpanel' \
	[5]='Container' \
	[6]='Power Supply' \
	[7]='Fan' \
	[8]='Sensor' \
	[9]='Module' \
	[10]='Port' \
	[11]='Stack' \
	)
	echo "${class_map[$int]}"
}
	


#
# MAIN
#

#
# set default values
#
mode=${mode:=fanHP}
filter=${filter:=.}
tout=${tout:=20}

check_snmp_args
check_threshold_args

case $mode in
	fanHP)
		# entPhysicalTable
		baseOID='.1.3.6.1.2.1.47.1.1.1.1'
		id[name]=7
		# id[class]=5
		get_bulk_snmp
		process_snmp_namedindex

		# class information is on leaf 5, fans have '7'
		filter_entity_byclass 5 7

		# Switch to hh3cEntityExtStateTable
		extOID='.1.3.6.1.4.1.25506.2.6.1.1.1.1'
		errorStatusOID="${extOID}.19"
		check_element_error_status $errorStatusOID 'Fans:'
		;;
	
	psuHP)
		# entPhysicalTable
		baseOID='.1.3.6.1.2.1.47.1.1.1.1'
		id[name]=7
		get_bulk_snmp
		process_snmp_namedindex

		# class information is on leaf 5, PSUs have '6'
		filter_entity_byclass 5 6

		# Switch to hh3cEntityExtStateTable
		extOID='.1.3.6.1.4.1.25506.2.6.1.1.1.1'
		errorStatusOID="${extOID}.19"
		check_element_error_status $errorStatusOID 'Power Supplies:'
		;;

	multi)
		# for this kind of check, the user can name the whole
		# thing using -n. Set a default here
		: ${checkName:=Physical Check: }
		outmsg="$checkName"

		# read whole entPhysicalTable one time
		baseOID='.1.3.6.1.2.1.47.1.1.1.1'
		id[name]=7
		get_bulk_snmp
		process_snmp_namedindex

		# Switch to hh3cEntityExtStateTable
		extOID='.1.3.6.1.4.1.25506.2.6.1.1.1.1'
		errorStatusOID="${extOID}.19"

		classes=( 7 6 )
		for class in ${classes[@]} ; do
			# class information is on leaf 5
			filter_entity_byclass 5 $class
			className=$( map_className $class )
			check_element_error_status $errorStatusOID "[$className] "
		done
		;;
	*)
		echo "(UNKNOWN): mode '-m $mode' not known" ; exit 3 ;;
esac


#
# Tell monitoring system what we found out
#
echo -en "$( state_string $glob_rcode ) $outmsg"
if [ -n "$details" ] ; then echo -en "\n\n$details" ; fi
if [ -n "$perfdata" ] ; then echo -en "|$perfdata" ; fi
echo

exit $glob_rcode
