#!/usr/bin/env bash

# This plugin retrieves volume, storagepool and RAID infomration from
# QNAP devices using SNMP. It takes into account the QNAP's status of
# volumes and pools and merges it with the CLI thesholds
#
# Author: Xin Qu
#
# Version: 1.3.1 2024-03-10
#	Features: Code consolidation
#
# Version: 1.3 2024-03-06
#	Features: Temperatures, System Info
#
# Version: 1.2 2023-02-14
#	Bugfixes
#
# Version: 1.1 2023-02-13
#	Added support for network targets (e.g. iSCSI)
#
# Version: 1.0 2023-02-09
#	First productive version
#
#

# Define Vars
declare -A snmpData
declare -A snmpUnit
declare -A id
declare -A nameMap

glob_rcode=0

#
# CLI Parsing
#

OPTERR=1
while getopts "H:C:u:x:X:a:A:l:w:c:m:f:F:t:Bhd" OPTION ; do
	case "${OPTION}" in
		H) hostname=${OPTARG}		;;
		C) community="-c ${OPTARG}" ;;
		u) authuser="-u ${OPTARG}"	;;
		a) authproto="-a ${OPTARG}" ;;
		A) authpass="-A ${OPTARG}"	;;
		x) privproto="-x ${OPTARG}" ;;
		X) privpass="-X ${OPTARG}"	;;
		l) seclevel="-l ${OPTARG}"	;;
		w) warn=${OPTARG}			;;
		c) crit=${OPTARG}			;;
		m) mode=${OPTARG}			;;
		f) filter=${OPTARG}			;;
		F) neg_filter=${OPTARG}		;;
		t) tout=${OPTARG}			;;
		B) nobulk=1					;;
		h) helpme=1					;;
		d) debug=1					;;
	esac
done

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Load library functions
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

callpath="$(dirname "$0")"
libdir="${callpath}/../lib"

source $libdir/generic_plugin.shlib
source $libdir/generic_snmp.shlib
source $libdir/convert_and_calc.shlib
#######
# Functions
#######

function calc_state() {
	local value=$1;local warn=$2;local crit=$3;local rcode

	if [ $value -gt $crit ] ; then
		rcode=2
	elif [ $value -gt $warn ] ; then
		rcode=1
	else
		rcode=0
	fi
	echo $rcode
}

# take into account the current global return code
function calc_globalstate() {
	local value=$1;local warn=$2;local crit=$3;local rcode

	rcode=$( calc_state $value $warn $crit )

	if [ $rcode -le $glob_rcode ] ; then
		rcode=$glob_rcode
	else
		rcode=$rcode
	fi
	echo $rcode
}

function set_globalstate() {
	local rcode=$1

	if [ $rcode -le $glob_rcode ] ; then
		rcode=$glob_rcode
	else
		rcode=$rcode
	fi
	echo $rcode
}

function state_string() {
	local rcode=$1
	local string
	case $rcode in
		0) string='(OK):' ;;
		1) string='(WARNING):' ;;
		2) string='(CRITICAL):' ;;
		3) string='(UNKNOWN):' ;;
	esac
	echo $string
}

function translate_pool_status() {
	local numcode=$1
	local version=$2
	local rstat
	version=QuTS

	case $version in
		QuTS)
			case $numcode in
				'-6')
					rstat='SED_LOCKED'		 ;;
				'-5')
					rstat='DETACHING'	;;
				'-4')
					rstat='REMOVING'	;;
				'-3')
					rstat='ERROR'	;;
				'-2')
					rstat='NOT_READY'	;;
				'-1')
					rstat='WARNING' ;;
				0)
					rstat='Ready'	;;
				1)
					rstat='ENABLE_QTIER'	;;
				2)
					rstat='SED_LOCKING' ;;
				3)
					rstat='SED_UNLOCKING'	;;
			esac;;
		QuHERO)
			case $numcode in
				'-4')
					rstat='SED_LOCKED'	;;
				'-3')
					rstat='ERROR'	;;
				'-2')
					rstat='NOT_READY'	;;
				'-1')
					rstat='WARNING' ;;
				0)
					rstat='Ready'	;;
				1)
					rstat='RESILVERING' ;;
				2)
					rstat='EXPORTING'	;;
				3)
					rstat='REMOVING'	;;
				4)
					rstat='SCRUBBING'	;;
				5)
					rstat='CREATING'	;;
				6)
					rstat='SED_LOCKING' ;;
				7)
					rstat='SED_UNLOCKING'	;;
				8)
					rstat='STOPPING'	;;
				9)
					rstat='STOPPED' ;;
				10)
					rstat='STARTING'	;;
				11)
					rstat='IMPORTING'	;;
				12)
					rstat='READONLY'	;;
				13)
					rstat='PRUNING' ;;
				14)
					rstat='TUNING'	;;
				0xFF)
					rstat='NONE_STATUS' ;;
			esac;;
	esac
	echo $rstat
}

function translate_target_status() {
	local numcode=$1

	case $numcode in
		'-1')
			rstat='offline'		;;
		0)
			rstat='ready'		 ;;
		1)
			rstat='connected'	 ;;
	esac
	echo $rstat
}

function mode_string() {
	local mode=$1
	local string
	case $mode in
		pool) string='Pools' ;;
		volume) string='Volumes' ;;
	target) string='Targets' ;;
	esac
	echo $string
}

# generate human readable bytes
function hr_bytes() {
	local rawbyte=$1
	local bstr=Byte

	# more than 10 TB
	if [ $rawbyte -gt 10000000000000 ] ;then
		hrbyte="$(( $rawbyte>>40 )) T$bstr"

	# more than 10 GB
	elif [ $rawbyte -gt 10000000000 ] ;then
		hrbyte="$(( $rawbyte>>30 )) G$bstr"

	# more than 10 MB
	elif [ $rawbyte -gt 10000000 ] ;then
		hrbyte="$(( $rawbyte>>20 )) M$bstr"
	fi

	echo $hrbyte
}


function storage_byfilter() {
	# Print Out Data for Elements, filtered by Name
	# By default, select all elements

	local filter=$1

	for eName in ${!nameMap[@]}
	do
		if [[  "$eName" =~ $filter ]]
		then
			outElements+=(${nameMap[$eName]})
		fi
	done

	local loop_rcode=0
	local loop_state
	if [ ${#outElements[@]} -ne 0 ] ; then
		outmsg+="$( mode_string $mode ): [used/total] "
	else
		outmsg+="No $( mode_string $mode ) found"
	fi

	for element in	${outElements[@]}
	do
		name=${snmpData[${baseOID}.${id[name]}.$element]}
		size_bytes=${snmpData[${baseOID}.${id[size]}.$element]}
		used_bytes=$(( \
			${snmpData[${baseOID}.${id[size]}.$element]} - \
			${snmpData[${baseOID}.${id[free]}.$element]} ))
		percent=$( percent $size_bytes $used_bytes )
		vol_status=${snmpData[${baseOID}.${id[status]}.$element]}

	if [ $mode == 'pool' ] ; then
	# Pools have a numeric status
		vol_status=$( translate_pool_status $vol_status )
	else
	# Volumes have a string status. Remove quotes.
		vol_status=$( echo $vol_status | tr -d '"' )
	fi
		
	# Calc local return code / state text string
	if [ -n "$warn" -a -n "$crit" ] ;then
		loop_rcode=$( calc_state ${percent} $warn $crit )

		# Update global plugin return code
		glob_rcode=$( calc_globalstate ${percent} $warn $crit )
	fi

	if [ $vol_status != 'Ready' ] ;then
		# Update global return code
		glob_rcode=$( set_globalstate 1 )
	fi

	loop_state=$( state_string $loop_rcode )
	# text output
	outmsg+="$name $(( used_bytes>>20 ))/$(( size_bytes>>20 )) MB (${percent}%) Status: $vol_status; "
	details+="Usage is $loop_state $name\n"
	details+="	Size:	$( hr_bytes $size_bytes )\n"
	details+="	Used:	$( hr_bytes $used_bytes ) (${percent}%)\n"
	details+="	Status: $vol_status (according to QNAP device)\n\n"
	perfdata+="$name=${percent}%;$warn;$crit;0;100 "
	done
}

function raid_byfilter() {
	# Print Out Data for Elements, filtered by Name
	# By default, select all elements

	local filter=$1

	for eName in ${!nameMap[@]}
	do
		if [[  "$eName" =~ $filter ]]
		then
			outElements+=(${nameMap[$eName]})
		fi
	done

	local loop_rcode=0
	local loop_state
	for element in	${outElements[@]}
	do
		name=${snmpData[${baseOID}.${id[name]}.$element]}
		size_bytes=${snmpData[${baseOID}.${id[size]}.$element]}
		raid_status=${snmpData[${baseOID}.${id[status]}.$element]}

		# Check Status
		case $raid_status in
			'"Ready"')
				loop_rcode=0;;
			'"Degraded"')
				loop_rcode=1;;
		esac
		loop_state=$( state_string $loop_rcode )
		glob_rcode=$( set_globalstate $loop_rcode )

		# text output
		outmsg+="RAID $name: Capacity $(( size_bytes>>30 )) GB, Status $raid_status; "
		details+="$loop_state $name\n"
		details+="	Size:	$( hr_bytes $size_bytes )\n"
		details+="	Status: $raid_status\n\n"
	done
}

function target_byfilter() {
	# Print Out Data for Elements, filtered by Name
	# By default, select all elements

	local filter=$1

	for eName in ${!nameMap[@]}
	do
		if [[  "$eName" =~ $filter ]]
		then
			outElements+=(${nameMap[$eName]})
		fi
	done

	if [ ${#outElements[@]} -ne 0 ] ; then
		outmsg+="$( mode_string $mode ): "
	else
		outmsg+="No $( mode_string $mode ) found"
	fi


	local loop_rcode=0
	local loop_state
	for element in	${outElements[@]}
	do
		local name=${snmpData[${baseOID}.${id[name]}.$element]}
		local iqn=${snmpData[${baseOID}.${id[iqn]}.$element]}
		local ip=${snmpData[${baseOID}.${id[ip]}.$element]}
		local target_status=${snmpData[${baseOID}.${id[status]}.$element]}
	local target_status_string=$( translate_target_status $target_status )

	# Map QNAP target status to return code
	case $target_status in
		-1) loop_rcode=2;;
		0)	loop_rcode=1;;
		1)	loop_rcode=0;;
	esac

		loop_state=$( state_string $loop_rcode )
		glob_rcode=$( set_globalstate $loop_rcode )

		# text output
		outmsg+="$name, Status: \"$target_status_string\"; "
		details+="$loop_state Target $name\n"
		details+="	IQN:	$iqn\n"
		details+="	IP:		$ip\n"
		details+="	Status: \"$target_status_string\"\n\n"
	done
}

function temperature {
	local cpuTemperature='.1.3.6.1.4.1.55062.1.12.10.0'
	local systemTemperature='.1.3.6.1.4.1.55062.1.12.11.0'

	# Check if there's a value
	if [ -z "${snmpData[$cpuTemperature]}" -o "${snmpData[$cpuTemperature]}" == 'No'  ] ;then
		outmsg+="Temperature not supported on this device. So we hope it's OK"
	else
		outmsg+="Temperatures: CPU: ${snmpData[$cpuTemperature]}℃  / System: ${snmpData[$systemTemperature]}℃"

		local value
		for value in cpuTemperature systemTemperature ; do
			perfdata+="$value=${snmpData[${!value}]} "
		done
	fi
}

function system_info {
	local type=$1
	if [ "$type" == 'soho' ] ; then
		local  subOID='.1.3.6.1.2.1.47.1.1.1.1'
		# Workaround: Set Hostname b/c it does not come from subOID
		local fakeOID='.1.3.6.1.2.1.47.1.1.1.1.12.1'
		local hostnameOID='.1.3.6.1.2.1.1.5.0'
		snmpData[$fakeOID]="${snmpData[$hostnameOID]}"
		snmpUnit[$fakeOID]=''

		local names=( Firmware SerialNo Hostname Model )
		local sequence="2 3 1 0"
		local oidOffset=10
		local oidSuffix=1
	else
		local subOID='.1.3.6.1.4.1.55062.1.12'
		local names=( Model Hostname SerialNo Firmware Upgradable )
		local sequence='1 0 2 3 4'
		local oidOffset=3
		local oidSuffix=0
		local updMap=( No Yes )
	fi
	local oid
	local idx
	local maxKeyLength=0
	local val
	local loop_line

	# find out longest keyname for pretty output
	for val in ${names[@]} ; do
		if [ ${#val} -gt $maxKeyLength ] ; then
			maxKeyLength=${#val}
		fi
	done

	for idx in $sequence ; do
		oid="${subOID}.$(( $idx + $oidOffset )).$oidSuffix"
		# Variant A: Output in first line
		if [ "${names[$idx]}" == 'Upgradable' ] ; then
			outmsg+="${names[$idx]}: ${updMap[${snmpData[$oid]}]}"
		else
			# remove quotes
			snmpData[$oid]=${snmpData[$oid]//\"/}
			outmsg+="${names[$idx]}: ${snmpData[$oid]} ${snmpUnit[$oid]}; "
		fi
		# Variant B: Output in Details
		#loop_line=$( printf "%-${maxKeyLength}s : %s" "${names[$idx]}" "${snmpData[$oid]}" )
		#details+="$loop_line\n"
	done
}

#
# MAIN
#

#
# set default values
#
mode=${mode:=volume}
filter=${filter:=.}
tout=${tout:=20}

check_snmp_args
check_threshold_args
#
# precission calculator 'bc' compat. check
#
if [ -x /usr/local/bin/bc ]; then
	bc=/usr/local/bin/bc
elif [ -x /usr/bin/bc ] ; then
	bc=/usr/bin/bc
fi

case $mode in
	pool)
		baseOID='.1.3.6.1.4.1.55062.1.10.7.1'
		id[index]=1
		id[name]=2
		id[size]=3
		id[free]=4
		id[status]=5
		get_snmp_and_process
		storage_byfilter $filter
	;;
	
	volume)
		baseOID='.1.3.6.1.4.1.55062.1.10.9.1'
		id[index]=1
		id[name]=8
		id[size]=3
		id[free]=4
		id[status]=5
		get_snmp_and_process
		storage_byfilter $filter
	;;
	
	raid)
		baseOID='.1.3.6.1.4.1.55062.1.10.5.1'
		id[index]=1
		id[name]=3
		id[size]=5
		id[status]=4
		get_snmp_and_process
		raid_byfilter $filter
	;;

	target)
		baseOID='.1.3.6.1.4.1.55062.1.10.22.1'
		id[index]=1
		id[name]=3
		id[iqn]=4
		id[ip]=5
		id[status]=6
		get_snmp_and_process
		target_byfilter $filter
	;;

	temperature)
		# cpuTemperature
		baseOID='.1.3.6.1.4.1.55062.1.12.10.0'
		get_snmp_and_process

		# systemTemperature
		baseOID='.1.3.6.1.4.1.55062.1.12.11.0'
		get_snmp_and_process
		temperature
	;;

	sysinfo)
		baseOID='.1.3.6.1.4.1.55062.1.12.3.0'
		get_snmp_and_process

	# Test whether MIB is supported
	if [ "${snmpData[$baseOID]}" == "No" ] ;then

		# Get bulk from entity mib
		sysinfo_type='soho'
		baseOID='.1.3.6.1.2.1.47.1.1.1.1'
		get_snmp_and_process

		# Get hostname
		get_snmp '.1.3.6.1.2.1.1.5.0'
	else
		sysinfo_type='enterprise'
		get_snmp '.1.3.6.1.4.1.55062.1.12.4.0'
		get_snmp '.1.3.6.1.4.1.55062.1.12.5.0'
		get_snmp '.1.3.6.1.4.1.55062.1.12.6.0'
		get_snmp '.1.3.6.1.4.1.55062.1.12.7.0'
	fi

	system_info $sysinfo_type

	;;

	*)
		echo "(UNKNOWN): mode '-m $mode' not known" ; exit 3 ;;
esac


#
# Tell monitoring system what we found out
#
echo -en "$( state_string $glob_rcode ) $outmsg"
if [ -n "$details" ] ; then echo -en "\n\n$details" ; fi
if [ -n "$perfdata" ] ; then echo -en "|$perfdata" ; fi
echo

exit $glob_rcode
