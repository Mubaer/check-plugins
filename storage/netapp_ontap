#!/usr/bin/env python3
#
# Check Netapp ONTAP via API
# 
# Author: Xin Qu <xinqu@v32bis.cc> pgp: 0x8D677421
#
# Version 1.2.1 2024-04-17
#   Added perfdata to volumes, aggregates, LUNs
#   Removed ':' from 1st output line
# Version 1.2 2024-04-17
#   New features: volumes, aggregates, LUNs
# Version 1.1 2024-04-12
#   sysinfo: move version from perfdata to plugin output
# Version 1.0 2024-04-10
#   1st release
#
# Version 0.1
#   first experimental version
#
import os, sys
import requests
requests.urllib3.disable_warnings()
import argparse
#from packaging.version import Version

# local libs
sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), '..'))
#from lib.jsonapi import *
from lib.generic_plugin import *

import pprint
pp=pprint.PrettyPrinter(indent=4, compact=True, sort_dicts=True)

#from datetime import *
#from datetime import datetime


# # # # # # # # # # # # # # # # # # # # # # # # # 
# MAIN
# # # # # # # # # # # # # # # # # # # # # # # # # 

# parse command line parameters

cli = argparse.ArgumentParser \
    (description='Check Sophos Cloud Services for Endpoint-Status or Alerts')

cli.add_argument('-H', help='Hostname or IP address', required = True)
cli.add_argument('--user', help='API username token', required =True)
cli.add_argument('--password', help='API password', required =True)
cli.add_argument('--port', help='tcp port to connect to (default 443)')
cli.add_argument('--mode', help='select check mode', required = True,
        choices=['sysinfo', 'hardware', 'agg', 'vol', 'lun'] )
cli.add_argument('--warn', help='warning theshold', type=int)
cli.add_argument('--warn-distance', help='distance to critical threshold (set inside netapp)', 
                 type=int, dest='warnDistance')
cli.add_argument('--crit', help='critical theshold', type=int)
cli.add_argument('-d', help='enable debugging messages', action='store_true', dest='DEBUG')
cli.add_argument('-t', help='test mode; fail randomly', action='store_true', dest='TEST')
args = cli.parse_args()
#pp = pprint.PrettyPrinter(indent=4, compact=True, sort_dicts=True)

# init vars
rcode=0
out_text=''
detail=''
perfdata=''

mode=args.mode
warn=args.warn
crit=args.crit
warnDistance=args.warnDistance
DEBUG=args.DEBUG
TESTING=args.TEST
auth=(args.user, args.password)
# /init vars

 
def sysinfo( host, token ):
    msg=''
    detail=''

    url="https://{}/api/cluster".format( host )
    resp = requests.get(url, auth=token, verify=False)
    jdata = resp.json()

    # Version
    jver = jdata.get('version')
    version='.'.join( [ str(jver['generation']), str(jver['major']), str(jver['minor']) ] )
    # Strip date from full version string
    full_version = jver['full'].partition(':')[0]

    msg += "{} @ {} | Version: '{}'".format( jdata.get('name'), jdata.get('location'), full_version )
    detail += "Cluster Name: {}\n".format( jdata.get('name') )
    detail += "Location:     {}\n".format( jdata.get('location') )
    detail += "Version:      {}\n".format( version )

    #pp.pprint( jdata )
    return [ msg, detail ]

def hardware( host, token ):
    rcode=0
    msg='Hardware Health'; detail=''

    #
    # Chassis
    #
    url="https://{}/api/cluster/chassis".format( host )
    resp = requests.get(url, auth=token, verify=False)
    chassis_data = resp.json()
    #if DEBUG: pp.pprint(chassis_data.get('records'))

    for chassis in  chassis_data.get('records'):
        chID = chassis.get('id')
        chURL="https://{}/api/cluster/chassis/{}?fields=frus,state,shelves".format( host, chID )
        chResp = requests.get(chURL, auth=token, verify=False)
        chData = chResp.json()

        rc_chassis=0
        if chData.get('state') != 'ok':
            rc_chassis=2

        detail += '{} Chassis: {}\n'.format(rcstring( rc_chassis ), chID )

        detail += "\tField replaceable units:\n"
        detail += "\t------------------------\n"
        errCount=0
        for fru in chData.get('frus'):
            tmpRC=0
            if fru['state'] != 'ok':

                tmpRC=2
                # Update global return code
                rcode = update_rc( tmpRC, rcode)
                errCount += 1

            detail+=("\t{}: {} {}".format( rcstring(tmpRC), fru['type'], fru['id'])+ "\n")

        if errCount > 0:
            msg += " | {} Chassis FRUs failed".format( errCount )

        detail += "\n"

        #
        # Nodes
        #
        url="https://{}/api/cluster/nodes".format( host )
        resp = requests.get(url, auth=token, verify=False)
        nodes_data = resp.json()

        indent='\t'
        node_failed = { 
            'bat' : 0,
            'failed_fan' : 0,
            'failed_power_supply' : 0
        }

        for node in nodes_data.get('records'):
            nodeURL="https://{}/api/cluster/nodes/{}".format( host, node['uuid'] )
            nodeResp = requests.get(nodeURL, auth=token, verify=False)
            nodeData = nodeResp.json()

            rc_node=0
            if nodeData.get('state') != 'up':
                rc_node=2
                msg +=' | {} != UP'.format( nodeData.get('name') )

            detail += '{}: Node: "{}", State: {}\n'.format( rcstring( rc_node ),  node['name'], nodeData.get('state') )

            # Battery
            bat = nodeData['nvram']['battery_state']

            tmpRC=0
            if bat != 'battery_ok':
                tmpRC=2
                # Update global return code
                rcode = update_rc( tmpRC, rcode)
                node_failed['bat'] += 1

            detail += "{}{}: NVRAM-Battery -- {}\n".format( indent, rcstring(tmpRC), bat )

            for item in [ 'failed_fan', 'failed_power_supply' ]:
                tmpRC=0
                numFailed = nodeData['controller'][item]['count']

                if numFailed > 0:
                    tmpRC = 2
                    # Update global return code
                    rcode = update_rc( tmpRC, rcode)
                    node_failed[ item ] += numFailed

                detail += "{}{}: #{} -- {}\n".format( indent,
                    rcstring(tmpRC),
                    numFailed,
                    nodeData['controller'][item]['message']['message'] )

            detail += "\n"
            #if DEBUG: pp.pprint(nodeData)

        # Summarize Nodes
        if node_failed['bat']:                   msg += ' | {} BATs failed'.format( failed['bat'])
        if node_failed['failed_fan']:            msg += ' | {} Fans failed'.format( failed['failed_fan'])
        if node_failed['failed_power_supply']:   msg += ' | {} PSUs failed'.format( failed['failed_power_supply'])



        #
        # Shelves
        #
        #num_shelves = len( chData.get('shelves') )

        #if DEBUG: 
        #    print('-------------------- shelves ----------------------------')
        #    pp.pprint(chData.get('shelves'))
        #    print('-------------------- /shelves ----------------------------')
        shelv_failed = {
                'fan' : 0,
                'fru' : 0,
                'bay' : 0
                }

        for shelv in chData.get('shelves'):
            shelvURL="https://{}/api/storage/shelves/{}".format( host, shelv['uid'] )
            shelvResp = requests.get(shelvURL, auth=token, verify=False)
            shelvData = shelvResp.json()

            #if DEBUG: detail += 'number of shelves: {}'.format( num_shelves )
            rc_shelv=0
            if shelvData.get('state') != 'ok':
                rc_shelv=2
                msg+=' | Shelv "{}" failed'.format(shelvData.get('name'))

            detail += '{}: Shelv: {} / {} / {} / SN: {} / {} disks\n'.format( rcstring( rc_shelv ),
                                 shelvData['name'] , shelvData['model'], 
                                 shelvData['module_type'], shelvData['serial_number'],
                                shelvData['disk_count'] )

            # Shelv Field replacable units
            detail += "\tField replaceable units:\n"
            detail += "\t------------------------\n"

            for fru in shelvData.get('frus'):
                tmpRC=0
                if fru['state'] != 'ok':
                    tmpRC=2
                    # Update global return code
                    rcode = update_rc( tmpRC, rcode)
                    shelv_failed['fru'] += 1

                detail+=("{}{}: {}  {}".format( indent, rcstring(tmpRC), fru['type'], fru['id'])+ "\n")

            # Shelv Fans
            detail += "\n\tFans:\n"
            detail += "\t-----\n"
            for fan in shelvData.get('fans'):
                tmpRC=0

                if fan['state'] != 'ok':
                    tmpRC=2
                    # Update global return code
                    rcode = update_rc( tmpRC, rcode)
                    shelv_failed['fan'] += 1

                detail+=("{}{}: id:{}, {}rpm, {}".format( indent, rcstring(tmpRC), fan['id'], fan['rpm'], fan['location'])+ "\n")

            # Shelv Disk Bays
            detail += "\n\tBays:\n"
            detail += "\t-----\n"
            detail += "\tState    \t  Type  \tID\thas disk?\n"

            for bay in shelvData.get('bays'):
                tmpRC=0

                if bay['state'] != 'ok':
                    tmpRC=2
                    # Update global return code
                    rcode = update_rc( tmpRC, rcode)
                    shelv_failed['bay'] += 1

                if bay['has_disk'] == True:
                    has_disk = '[ Y ]'
                else:
                    has_disk = '[ - ]'

                detail+="{}{}\t{}\t{}\t{}\n".format( indent, rcstring(tmpRC,lineup=1), bay['type'], bay['id'], has_disk )

            if DEBUG: 
                print('-------------------- shelv ----------------------------')
                pp.pprint(shelvData)
                print('-------------------- /shelv ----------------------------')
        # Sumarize Shelves
        if shelv_failed['fan']: msg += ' | {} Fans failed'.format( shelv_failed['fan'] )
        if shelv_failed['fru']: msg += ' | {} FRUs failed'.format( shelv_failed['fru'] )
        if shelv_failed['bay']: msg += ' | {} Bays failed'.format( shelv_failed['bay'] )

    detail += '\n'

    #
    # Disks
    #
    (disk_msg, disk_detail, disk_rcode) = check_disks( host, token )

    msg     += disk_msg
    detail  += disk_detail
    rcode    = update_rc( disk_rcode, rcode )


    return [ msg, detail, rcode ]


#
# Disks
#
def check_disks (host, token):
    msg=''
    detail  = 'Disks\n'
    detail += '-----\n'
    detail += '\tState    \tName\tPool\tCType\tbay\n'
    diskRC = 0

    url="https://{}/api/storage/disks".format( host )
    resp = requests.get(url, auth=token, verify=False)
    disks = resp.json()
    for disk in sorted( disks.get('records'), key=lambda x: tuple(map(int, x['name'].split('.')) ) ):
        tmpRC=0
        diskHref=disk['_links']['self']['href']
        diskURL="https://{}{}".format( host, diskHref )
        diskResp = requests.get(diskURL, auth=token, verify=False)
        diskData = diskResp.json()

        linearray = []
        for key in ( 'name', 'pool', 'container_type', 'bay' ):
            linearray.append( str( diskData.get( key ) ))

        #TESTING
        if TESTING:
            if diskData.get('name') == '1.0.4': diskData['container_type'] = 'broken'
        #/TESTING
        if diskData.get('container_type') in [ 'broken', 'unassigned' ]:
            tmpRC = 2
            msg+=' | container type of disk {}={}'.format( 
                              diskData.get('name'), diskData.get('container_type' ) )
            if tmpRC > diskRC:
                diskRC = tmpRC



        detail += '\t'.join( [ '', rcstring( tmpRC, lineup=1) ] +  linearray ) + '\n'

        if DEBUG:
            print('-------------------- disk ----------------------------')
            pp.pprint( diskData )
            print('-------------------- disk ----------------------------')

    return [ msg, detail, diskRC ]


#
# Aggregates
#
def check_aggregates (host, token, warnDistance, warn, crit):
    msg      = ''
    detail   = ''
    perfdata = ''
    aggRC  = 0
    if not warnDistance: warnDistance=5

    url="https://{}/api/storage/aggregates".format( host )
    resp = requests.get(url, auth=token, verify=False)
    aggs = resp.json()
    msg += ' Checked {} Aggregates'.format( len(aggs.get('records')) )
    #for agg in sorted( aggs.get('records'), key=lambda x: aggs.get('name') ):
    for agg in  aggs.get('records'):
        tmpRC=0
        aggHref=agg['_links']['self']['href']
        aggURL="https://{}{}?fields=name,space,state".format( host, aggHref )
        aggResp = requests.get(aggURL, auth=token, verify=False)
        aggData = aggResp.json()

        used = aggData.get('space').get('block_storage').get('used')
        size = aggData.get('space').get('block_storage').get('size')
        critThreshold = aggData.get('space').get('block_storage').get('full_threshold_percent')
        state = aggData.get('state')
        name = aggData.get('name')

        percent_used = ( used / size ) * 100

        # TESTING
        if TESTING:
            if name == 'aggr_data01_node2':
                state= 'offlines'
            if name == 'aggr_data01_node1':
                percent_used = 97
        # /TESTING 

        if state != 'online':
            tmpRC=1
            msg += " | Status {}={} (expected: 'online')".format(name, state)
            if tmpRC > aggRC:
                aggRC=tmpRC

        # Critical condition
        if percent_used >= critThreshold:
            tmpRC=2
            msg += ' | Usage above crit {}(used {}%)'.format(name, percent_used)
            if tmpRC > aggRC:
                aggRC=tmpRC
        # Warning condition 
        elif percent_used >= (critThreshold - warnDistance):
            tmpRC=1
            msg += ' | Usage above warn {}(used {}%)'.format(name, percent_used)
            if tmpRC > aggRC:
                aggRC=tmpRC

        detail += '{} {}; {}; used: {:.1f}%; thresholds: warn {}% / crit {}%\n'.format(rcstring( tmpRC, lineup=1 ), name, state, percent_used, (critThreshold - warnDistance ), critThreshold)
        perfdata += '{}={:.1f}%;{};{} '.format(name, percent_used, (critThreshold - warnDistance), critThreshold)

        if DEBUG:
            print('-------------------- Aggreagate -----------------------')
            pp.pprint( aggData )
            print('-------------------- /Aggreagate ----------------------')

    return [ msg, detail, aggRC, perfdata ]

#
# Volumes
#
def check_volumes (host, token, warn, crit):
    msg      = ''
    detail   = ''
    perfdata = ''
    volRC = 0

    url="https://{}/api/storage/volumes".format( host )
    resp = requests.get(url, auth=token, verify=False)
    vols = resp.json()
    msg += ' Checked {} Volumes'.format( len(vols.get('records')) )

    for vol in sorted( vols.get('records'), key=lambda x: x.get('name') ):
        tmpRC=0
        volHref=vol['_links']['self']['href']
        volURL="https://{}{}?fields=name,space,state".format( host, volHref )
        volResp = requests.get(volURL, auth=token, verify=False)
        volData = volResp.json()

        percent_used = 100 - volData.get('space').get('available_percent') 
        critThreshold = volData.get('space').get('full_threshold_percent')
        warnThreshold = volData.get('space').get('nearly_full_threshold_percent')
        state = volData.get('state')
        name = volData.get('name')

        # TESTING
        if TESTING:
            if name == 'vol_vmfs20':
                state= 'offlines'
            if name == 'vol_vmfs11':
                percent_used = 97
        # /TESTING 

        if state != 'online':
            tmpRC=1
            msg += " | Status {}={} (expected 'online')".format(name, state)
            if tmpRC > volRC:
                volRC=tmpRC

        if percent_used >= critThreshold:
            tmpRC=2
            if tmpRC > volRC:
                volRC=tmpRC
            msg += ' | Usage above crit {}(used {:.1f}%)'.format(name, percent_used)
        elif percent_used >= warnThreshold:
            tmpRC=1
            if tmpRC > volRC:
                volRC=tmpRC
            msg += ' | Usage above warn {}(used {:.1f}%)'.format(name, percent_used)

        detail += '{} {}; {}; used: {:.1f}%; thesholds: warn {}% / crit {}%\n'.format(rcstring( tmpRC, lineup=1 ), name, state, percent_used, warnThreshold, critThreshold)
        perfdata += '{}={}%;{};{} '.format(name, percent_used, warnThreshold, critThreshold)

        if DEBUG:
            print('-------------------- Volume -----------------------')
            pp.pprint( volData )
            print('-------------------- /Volume ----------------------')

    return [ msg, detail, volRC, perfdata ]

#
# LUNs
#
def check_luns (host, token, warn, crit):
    msg      = ''
    detail   = ''
    perfdata = ''
    lunRC = 0

    crit = crit or 95
    warn = warn or 90

    url="https://{}/api/storage/luns".format( host )
    resp = requests.get(url, auth=token, verify=False)
    luns = resp.json()
    msg += ' Checked {} LUNs'.format( len(luns.get('records')) )
    for lun in sorted( luns.get('records'), key=lambda x: x.get('name') ):
        tmpRC=0
        lunHref=lun['_links']['self']['href']
        lunURL="https://{}{}?fields=name,space,status".format( host, lunHref )
        lunResp = requests.get(lunURL, auth=token, verify=False)
        lunData = lunResp.json()

        #percent_used = 100 - lunData.get('space').get('available_percent') 
        state = lunData.get('status').get('state')
        name = lunData.get('name')
        percent_used= ( lunData.get('space').get('used') / lunData.get('space').get('size') ) * 100

        # TESTING
        if TESTING:
            if name == '/vol/vol_vmfs12/vmfs12':
                state= 'offlines'
        # /TESTING 

        if state != 'online':
            tmpRC=1
            msg += " | Status {}={} (expected 'online')".format(name, state)
            if tmpRC > lunRC:
                lunRC=tmpRC

        if percent_used >= crit:
            tmpRC=2
            if tmpRC > lunRC:
                lunRC=tmpRC
            msg += ' | Usage above crit {}(used {:.1f}%)'.format(name, percent_used)
        elif percent_used >= warn:
            tmpRC=1
            if tmpRC > lunRC:
                lunRC=tmpRC
            msg += ' | Usage above warn {}(used {:.1f}%)'.format(name, percent_used)

        detail += '{} {}; {}; used: {:.1f}%; thesholds: warn {}% / crit {}%\n'.format(rcstring( tmpRC, lineup=1 ), name, state, percent_used, warn, crit)
        perfdata += '{}={:.1f}%;{};{} '.format(name, percent_used, warn, crit)

        if DEBUG:
            print('-------------------- LUN -----------------------')
            pp.pprint( lunData )
            print('-------------------- /LUN ----------------------')

    return [ msg, detail, lunRC, perfdata ]

# User non-standard port number?
if args.port:
    hostname = args.H + ':' + args.port
else:
    hostname = args.H

# Select check mode
if mode=='sysinfo':
    out_text, detail = sysinfo(hostname, auth)
elif mode=='hardware':
    out_text, detail, rcode = hardware(hostname, auth)
elif mode=='agg':
    out_text, detail, rcode, perfdata = check_aggregates(hostname, auth, warnDistance, warn, crit)
elif mode=='vol':
    out_text, detail, rcode, perfdata = check_volumes(hostname, auth, warn, crit)
elif mode=='lun':
    out_text, detail, rcode, perfdata = check_luns(hostname, auth, warn, crit)
else:
    rcode=3
    out_text='Option "--mode" required'


#Finally, print check output and exit with rcode
print(  plugin_output( rcode, out_text, detail, perfdata ) )

sys.exit(rcode)

