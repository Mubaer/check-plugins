#!/usr/bin/env bash

# This plugin checks Synology NAS
#
# Author: Xin Qu
#
# Version: 1.0 2025-10-15
#	+ added raid volume support
#
# Version: 0.4 2025-10-07
#	+ bugfix in perfdata for disks
#
# Version: 0.3 2025-09-30
#	+ added disk check: Status and Temperature
#
# Version: 0.2 2025-09-08
#	+ added units for entity_value()
#
# Version: 0.1 2025-09-08
#	First test version
#	Checks for Temperature, PSU, Fan, Health
#

# Define Vars
declare -A snmpData
declare -A snmpUnit
declare -A id
declare -A nameMap

glob_rcode=0

#
# CLI Parsing
#

OPTERR=1
while getopts "H:C:u:x:X:a:A:l:w:c:m:f:F:t:Bhd" OPTION ; do
	case "${OPTION}" in
		H) hostname=${OPTARG}		;;
		C) community="-c ${OPTARG}" ;;
		u) authuser="-u ${OPTARG}"	;;
		a) authproto="-a ${OPTARG}" ;;
		A) authpass="-A ${OPTARG}"	;;
		x) privproto="-x ${OPTARG}" ;;
		X) privpass="-X ${OPTARG}"	;;
		l) seclevel="-l ${OPTARG}"	;;
		w) warn=${OPTARG}			;;
		c) crit=${OPTARG}			;;
		m) mode=${OPTARG}			;;
		f) filter=${OPTARG}			;;
		F) neg_filter=${OPTARG}		;;
		t) tout=${OPTARG}			;;
		B) nobulk=1					;;
		h) helpme=1					;;
		d) debug=1					;;
	esac
done

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Load library functions
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

callpath="$(dirname "$0")"
libdir="${callpath}/../lib"

source $libdir/generic_plugin.shlib
source $libdir/generic_snmp.shlib
source $libdir/convert_and_calc.shlib

#######
# Functions
#######

function status_stringmap {
	local numState=$1
	local entity=$2

	local -a map
	case $entity in
		1)
			# System
			map[1]='System functionals normally.'
			map[2]='Volume has crashed.'
			;;
		3)
			# PSUs
			map[1]='All power supplies functional normally.'
			map[2]='One of power supply has failed.'
			;;
		4.1)
			# System Fans
			map[1]='All Internal fans functional normally.'
			map[2]='One of internal fan stopped.'
			;;
		4.2)
			# CPU Fans
			map[1]='All CPU fans functional normally.'
			map[2]='One of CPU fan stopped.'
			;;
		5.?)
			map[1]='Normal'
			map[2]='Initialized'
			map[3]='Not Initialized'
			map[4]='System Partition Failed'
			map[5]='Crashed'
			;;
	esac

	echo "${map[$numState]}"
}

function status_stringmap_raid {
	local numState=$1
	local -a map
	map[1]='Normal'
	map[2]='Repairing'
	map[3]='Migrating'
	map[4]='Expanding'
	map[5]='Deleting'
	map[6]='Creating'
	map[7]='RaidSyncing'
	map[8]='RaidParityChecing'
	map[9]='RaidAssembling'
	map[10]='Canceling'
	map[11]='Degraded'
	map[12]='Crashed'
	echo "${map[$numState]}"
}

function status_errormap_raid {
	local numState=$1
	map[1]=0
	map[2]=1
	map[3]=0
	map[4]=0
	map[5]=0
	map[6]=0
	map[7]=0
	map[8]=0
	map[9]=0
	map[10]=0
	map[11]=1
	map[12]=2
	echo "${map[$numState]}"
}

function status_errormap {
	local numState=$1
	local entity=$2

	local -a map
	case $entity in
		[13])
			# System, PSU
			map[1]=0
			map[2]=2
			;;
		4.?)
			# System, PSU
			map[1]=0
			map[2]=2
			;;
		5.?)
			# Disk Status
			map[1]=0
			map[2]=0
			map[3]=0
			map[4]=1
			map[5]=2
			;;
		*)
			# something went wrong!
			echo 3
	esac

	echo "${map[$numState]}"
}

# For single fan OIDs
# Introduced for Synology, hope it works out for other devices also
function entity_status {
	local subid=$1
	local description=$2
	local auto_zero_index=$3
	local override_mapping=$4

	if [ "$auto_zero_index" == 'z' ] ; then
		local dotzero='.0'
	else
		local dotzero=''
	fi
	local entity_status="${snmpData[${baseOID}.${subid}${dotzero}]}"
	local entitystate_string=$( status_stringmap${override_mapping} $entity_status $subid)
	local entitystate_mapped=$( status_errormap${override_mapping} $entity_status $subid)
	local state_string=$( state_string $entitystate_mapped n n )

	glob_rcode=$( set_globalstate $entitystate_mapped )
	details+="$state_string $description: $entitystate_string\n"
	outmsg+="$description $state_string "
}

# entity_value SubOID Unit WARN CRIT Description
function entity_value {
	local subid=$1
	local unit=$2
	local warn=$3
	local crit=$4
	local description=$5
	local perf_name=$6
	local auto_zero_index=$7
	local override_mapping=$8

	if [ "$auto_zero_index" == 'z' ] ; then
		local dotzero='.0'
	else
		local dotzero=''
	fi

	local entity_value="${snmpData[${baseOID}.${subid}${dotzero}]}"

	local value_state=$( calc_state "$entity_value" "$warn" "$crit" )
	glob_rcode=$( set_globalstate $value_state )

	local state_string=$( state_string $value_state n n )

	#glob_rcode=$( set_globalstate $entitystate_mapped )
	details+="$state_string $description: $entity_value $unit\n"
	outmsg+="$description $state_string "

	if [ "$perf_name" ] ; then
		perfdata+="'$perf_name'=$entity_value;$warn;$crit "
	fi
}

function entity_value_raid {
	local entity_value=$1
	local unit=$2
	local warn=$3
	local crit=$4
	local description=$5
	local perf_name=$6

	local value_state=$( calc_state "$entity_value" "$warn" "$crit" )
	glob_rcode=$( set_globalstate $value_state )

	local state_string=$( state_string $value_state n n )

	#glob_rcode=$( set_globalstate $entitystate_mapped )
	details+="$state_string $description: $entity_value $unit\n"
	outmsg+="$description $state_string "

	if [ "$perf_name" ] ; then
		perfdata+="'$perf_name'=$entity_value;$warn;$crit "
	fi
}

function check_disk {
	local warn=$1
	local crit=$2
	local perf_name
	local disk
	for disk in "${!nameMap[@]}" ; do
		disk_id=${nameMap[$disk]}
		perf_name="${disk//\"/}"
		entity_status 5.$disk_id "$disk Status"
		entity_value  6.$disk_id '°C' "$warn" "$crit" "$disk Temperature" "$perf_name"
		details+="\n"
	done
}

function check_raid {
	local warn=$1
	local crit=$2
	# Iterate over Raid Volumes
	local rvol
	for rvol in "${!nameMap[@]}" ; do
		local rvol_id=${nameMap[$rvol]}
		local perf_name="${rvol//\"/}"

		local free="${snmpData[${baseOID}.4.${rvol_id}]}"
		local total="${snmpData[${baseOID}.5.${rvol_id}]}"

		local used="$(( $total - $free ))"
		local used_pct=$(( $used * 100 / $total ))
		entity_status 3.$rvol_id "$rvol Status" 'n' '_raid'
		entity_value_raid  $used_pct '%' "$warn" "$crit" "$rvol Usage" "$perf_name"
	done
}

#
# MAIN
#

#
# set default values
#
mode=${mode:=health}
filter=${filter:=.}
tout=${tout:=20}

check_snmp_args
check_threshold_args

case $mode in
	health)
		baseOID='.1.3.6.1.4.1.6574.1'
		get_snmp_lib

		outmsg+="Health: "
		entity_status 1 "System Status" z
		;;
	psu)
		baseOID='.1.3.6.1.4.1.6574.1'
		get_snmp_lib

		outmsg+="PSUs: "
		entity_status 3 "Power Status" z
		;;
	fan)
		# only fetch fan subOID
		baseOID='.1.3.6.1.4.1.6574.1.4'
		get_snmp_lib

		# change base for processing
		baseOID='.1.3.6.1.4.1.6574.1'

		outmsg+="Fans: "
		entity_status 4.1 "System Fans" z
		outmsg+=", "
		entity_status 4.2 "CPU Fans" z
		;;
	temp*)
		baseOID='.1.3.6.1.4.1.6574.1'
		get_snmp_lib

		: ${warn:=60}
		: ${crit:=70}
		outmsg+="Temperature: "
		entity_value 2 '°C' "$warn" "$crit" "Disk Station" temp z
		;;
	disk)
		baseOID='.1.3.6.1.4.1.6574.2.1.1'
		get_snmp_lib nounit
		id[index]=1
		id[name]=2
		process_snmp_index
		: ${warn:=45}
		: ${crit:=55}
		check_disk $warn $crit
		;;
	raid)
		baseOID='.1.3.6.1.4.1.6574.3.1.1'
		get_snmp_lib nounit
		id[index]=1
		id[name]=2
		process_snmp_index
		: ${warn:=90}
		: ${crit:=95}
		check_raid $warn $crit
		;;

	*)
		echo "(UNKNOWN): mode '-m $mode' not known" ; exit 3 ;;
esac

#
# Tell monitoring system what we found out
#
trigger_exit
