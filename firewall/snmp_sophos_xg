#!/usr/bin/env bash

# This plugin retrieves cpu or license status from Sophos XG firewalls
#
# Author: msander
#
# Version: 0.4  2023-04-17
#   removed library functions and new features
#
#     - removed functions which were moved to /lib/
#     - added feature "ha" (high availablity)
#     - added feature "tunnel" (list vpn tunnels)
#
# Version: 0.3  2023-03-28
#   new feature and small fixes
#
#    - Added complicated new feature "Sophos Licenses"
#    - Fixed a bug where SNMP-Data was truncated (spaces in output)
#    - Added a 'dbg_msg' function for debugging output to stderr
#    - Fixed indentation
#
## Version: 0.2  2023-03-27
#   fixed perfdata output
#
# Version: 0.1  2023-03-27
#   first version rolled out for testing
#

# Define Vars
declare -A snmpData
declare -A id
declare -A nameMap
declare -a elementList

glob_rcode=0

#
# CLI Parsing
#

OPTERR=1
while getopts "H:C:u:x:X:a:A:l:w:c:m:f:F:t:Bhd-:" OPTION ; do
    case "${OPTION}" in
        H) hostname=${OPTARG}       ;;
        C) community="-c ${OPTARG}" ;;
        u) authuser="-u ${OPTARG}"  ;;
        a) authproto="-a ${OPTARG}" ;;
        A) authpass="-A ${OPTARG}"  ;;
        x) privproto="-x ${OPTARG}" ;;
        X) privpass="-X ${OPTARG}"  ;;
        l) seclevel="-l ${OPTARG}"  ;;
        w) warn=${OPTARG}           ;;
        c) crit=${OPTARG}           ;;
        m) mode=${OPTARG}           ;;
        f) filter=${OPTARG}         ;;
        F) neg_filter=${OPTARG}     ;;
        t) tout=${OPTARG}           ;;
        B) nobulk=1                 ;;
        h) helpme=1                 ;;
        d) debug=1                  ;;
        -)
            OPTION=${OPTARG/=*/}
            OPTARG=${OPTARG/*=/}
            case ${OPTION} in
                ha-disabled-rc) ha_disabled_rc=$OPTARG;;
                ha-localstate-ok)    ha_local_status_ok=$OPTARG;;
                ha-peerstate-ok)     ha_peer_status_ok=$OPTARG;;
                *) echo "unknown option $OPTION"; exit 3;;
            esac

    esac
done

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Load library functions
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

callpath="$(dirname "$0")"
libdir="${callpath}/../lib"

source $libdir/generic_plugin.shlib
source $libdir/generic_snmp.shlib
source $libdir/convert_and_calc.shlib
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local functions
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

function mode_string() {
    local mode=$1
    local string
    case $mode in 
        cpu) string='CPU' ;;
        license) string='Licenses' ;;
    esac
    echo $string
}

function date_to_epoch {
    # Try to convert various date formats to epoch seconds

    local regex[0]='[A-Z][a-z]{2} +[0-9]+ [0-9]{4}"'
    local datefmt[0]='"%b %e %Y"'
    local regex[1]='([A-Z][a-z]{2} ){2} *[0-9]+ ([0-9]{2}:){2}[0-9]{2} [0-9]{4}'
    local datefmt[1]='"%a %b %e %T %Y"'
    local input="$1"
    local epoch=0

    for re in 0 1 ; do
        if [[ "$input" =~ ${regex[$re]} ]] ; then
        dbg_msg "Date $input matches ${regex[$re]}"
            epoch=$( date -j -f "${datefmt[$re]}" "$input" +%s )
    else
        dbg_msg "Date $input NOT matches ${regex[$re]}"
    fi
    done

    echo $epoch
}

function license_check {
    local licenseNames=( Base NetProtect WebProtect MailProtect WebServer Sandstorm EnhancedSupport EnhancedPlusSupport  C-Orchestration )
    local subOID
    local licStatus
    # Beware! We need negative values here
    local lic_warn=-${warn:-30}
    local lic_crit=-${crit:-7}
    local lic_rcode=0
    local loop_rcode=0
    local lic_data_invalid=0
    # initialize counter array
    local licenseCounter=( 0 0 0 0 0 )
    local statusNames=( none trial unsubscribed subscribed expired )
    # Seconds per Day
    local s2d=86400

    local epoch_current=`date +%s`

    details+='Licenses in detail:\n'

    for licIndex in ${!licenseNames[@]}; do
        # Skip 'Base' license because it has no usabel value
        if [ $licIndex -eq 0 ] ; then continue ; fi

        # License Status
        subOID="${baseOID}.$(( licIndex +1 )).1.0"
        licStatus=${snmpData[$subOID]}
        # if there's no license info in snmp, set status to '0=none'
        if [ -z "$licStatus" ] ;then
            licStatus=0
        fi
        licenseCounter[$licStatus]=$(( licenseCounter[$licStatus] + 1 ))

        # Expiration Date
        subOID="${baseOID}.$(( licIndex +1 )).2.0"
        human_expire=${snmpData[$subOID]}

        # Special Case invalid date from snmp
        if [ "$human_expire" == '"fail"' -o "$human_expire" == '' ] ; then 
            lic_data_invalid=1
        else
            lic_data_invalid=0
        fi

        if [ $lic_data_invalid -ne 1 ] ; then
            epoch_expire=$( date_to_epoch "$human_expire" )
            days_til_expire=$(( (epoch_expire - epoch_current) / s2d ))

            # skip state calculations when status is 'expired/4' anyway
            if [ $licStatus -eq 4 ] ; then
                loop_rcode=2
            else 
                loop_rcode=$( calc_state $(( -$days_til_expire )) $lic_warn $lic_crit )
            fi

            # different output text when exp. date is negative
            if [ $days_til_expire -gt 0 ] ; then
                expday_text='days until '
                exp_text='expires'
            else
                expday_text='days since '
                exp_text='expired'
            fi

            glob_rcode=$( set_globalstate $loop_rcode )
            loop_line=$( printf "%-10s %4s $expday_text %19s $exp_text on $human_expire, status \"${statusNames[$licStatus]}\""  `state_string $loop_rcode` $days_til_expire "${licenseNames[$licIndex]}" )

        else
            loop_line=$( printf "(no license?): no date for  %19s expiration date unknown, status \"${statusNames[$licStatus]}\"\n" "${licenseNames[$licIndex]}" )
        fi

        details+="   $loop_line\n"
    done

    outmsg+="Number of Licenses: Trial = ${licenseCounter[1]}, Unsubscribed = ${licenseCounter[2]}, Subscribed = ${licenseCounter[3]}, Expired = ${licenseCounter[4]}"
}

function check_vpntunnel() {
    # Print Out Data for Elements, filtered by Name
    # By default, select all elements

    local filter=$1

    local name; local descr; local mode; local type

    #for eName in ${!nameMap[@]}
    #do
    #    if [[  "$eName" =~ $filter ]]
    #    then
    #        outElements+=(${nameMap[$eName]})
    #    fi
    #done

    #local loop_rcode=0
    #local loop_state
    for element in  ${elementList[@]}
    do
    loop_line=$( printf "Tunnel %s: Pol.: '%s', Mode: '%s', Type: '%s', Port '%s', Active: '%s'" \
        "${snmpData[${baseOID}.${id[name]}.$element]}"     \
        "${snmpData[${baseOID}.${id[policy]}.$element]}"    \
        "${snmpData[${baseOID}.${id[mode]}.$element]}"     \
        "${snmpData[${baseOID}.${id[type]}.$element]}"     \
        "${snmpData[${baseOID}.${id[port]}.$element]}"     \
        "${snmpData[${baseOID}.${id[active]}.$element]}"     \
    )

        # text output
        #outmsg+="RAID $name: Capacity $(( size_bytes>>30 )) GB, Status $raid_status; "
        #details+="Tunnel [$name]: Desc: $desc, Mode: $mode, Type: $type\n"
        details+="$loop_line\n"
    done
    outmsg="VPN Tunnels (informative)"
}

function ha_state() {
    local numState=$1
    local stateName=( n/a auxiliary standAlone primary faulty ready )
    if [ "${stateName[$numState]}" == '' ] ; then
        dbg_msg "no name defined for status '$numState'"
        exit 10
    else
        echo ${stateName[$numState]}
    fi
}

function ha_status() {
    local numState=$1
    local stateName=( disabled enabled )
    if [ "${stateName[$numState]}" == '' ] ; then
        dbg_msg "no name defined for status '$numState'"
        exit 10
    else
        echo ${stateName[$numState]}
    fi
}

function check_ha() {
    local keyname=( dummy HAStatus CurrentAppKey PeerAppKey CurrentHAState PeerHAState \
                HAConfigMode LoadBalancing HAPort HACurrentIP HAPeerIP )
    
    local idx
    local ha_local_status
    local ha_peer_status
    for idx in ${!keyname[@]} ; do
        case $idx in
            [023])  continue;;
            1)
                details+="${keyname[$idx]} is $( ha_status ${snmpData[${baseOID}.$idx.0]} )\n"
                if [ "${snmpData[${baseOID}.$idx.0]}" -eq 0 ] ; then
                    glob_rcode=$( set_globalstate $ha_disabled_rc )
                    break
                fi
                ;;
            4)
                ha_local_status=$( ha_state ${snmpData[${baseOID}.$idx.0]} )
                if [ $ha_local_status != $ha_local_status_ok ] ; then
                    glob_rcode=$(set_globalstate 1)
                    details+="(WARN): ${keyname[$idx]} is $ha_local_status, expected $ha_local_status_ok\n"
                else
                    details+="${keyname[$idx]} is $ha_local_status\n"
                fi
                ;;
            5)
                ha_peer_status=$( ha_state ${snmpData[${baseOID}.$idx.0]} )
                if [ $ha_peer_status != $ha_peer_status_ok ] ; then 
                    glob_rcode=$(set_globalstate 1)
                    details+="${keyname[$idx]} is $ha_peer_status, expected $ha_peer_status_ok\n"
                else
                    details+="${keyname[$idx]} is $ha_peer_status\n"
                fi
                ;;
            *)
                details+="${keyname[$idx]} is ${snmpData[${baseOID}.$idx.0]}\n"
                ;;
        esac
    done
    outmsg="HA Status (informative)"

}

function get_snmp {
    #
    # Compose snmp command
    #
    if [ "$nobulk" ]; then walk=snmpwalk;  else walk=snmpbulkwalk; fi
    if [ -n "$authuser" ]; then snmpv=3; else snmpv=2c; fi

    snmpcmd="$walk -Onq -v $snmpv -t $tout -r 3 \
        $community $authuser $privproto $privpass $seclevel $authproto $authpass \
        $hostname  $baseOID"

    dbg_msg "debug snmpcmd: $snmpcmd"


    # First of all, get the SNMP-Data
    snmpResponse=$($snmpcmd 2>&1)
    snmpexit=$?

    dbg_msg "debugsnmpresponse: $snmpResponse"

    if [ $snmpexit -ne 0 ] ; then
        echo "(UNKNOWN): Problem fetching SNMP data."
        echo 
        echo "SNMP Output was: $snmpResponse"
        exit 3
    fi

    while read oid value
    do 
        snmpData[$oid]="$value"
    done <<< "$snmpResponse"
}

function process_snmp_index {
    #### building indexes
    #

    # build element index
    for key in ${!snmpData[@]} ; do
        if [[ $key == "$baseOID.${id[index]}"* ]] ; then
        elementIndex+=( ${snmpData[$key]} )
        fi
    done

    # build name map
    for element in  ${elementIndex[@]}
    do
        nameMap[${snmpData[${baseOID}.${id[name]}.$element]}]=${snmpData[${baseOID}.${id[index]}.$element]}
    done
    #
    #
    #### / building indexes
}

function process_snmp_noindex {
    #### building indexes
    #

    # build element list
    local element_counter=0
    for element in ${snmpData[@]} ; do
            elementList[$element_counter]=$element
            : $(( element_counter++ ))
    done
}

function process_snmp_namedindex {
    #### building indexes
    #

    #local index_key
    # build element index. Last OID-Tree-Level is the index
    for key in ${!snmpData[@]} ; do
        if [[ $key == "$baseOID.${id[name]}".* ]] ; then
        key=${key/.*\./}
        elementList+=( $key )
        fi
    done

    # build name map
    for element in  ${elementList[@]}
    do
        nameMap[$element]=${snmpData[${baseOID}.${id[name]}.$element]}
    done

    #
    #
    #### / building indexes
}

function cpu_check {
    local cpu_percent
    local cpu_sum=0
    local cpu_avg
    local cpu_count=${#elementList[@]}
    local cpu_warn=${warn:-0}
    local cpu_crit=${crit:-0}

    if [ $cpu_count -gt 1 ] ; then
        # sum up cpu percents
        for cpu_item in ${elementList[@]} ; do
            cpu_sum=$(( cpu_sum + cpu_item ))
        done
        cpu_avg=$(( cpu_sum / cpu_count ))
    else
        cpu_avg=${elementList[0]}
    fi

    glob_rcode=$( set_globalstate 0 )
    # text output
    outmsg+="Average CPU utiliziation ${cpu_avg}%"
    perfdata+="avg_cpu=${cpu_avg}%;$cpu_warn"

    if [ $cpu_count -gt 1 ] ; then
        for cpu_index in ${!elementList[@]} ; do
            perfdata+=" cpu_${cpu_index}=${elementList[$cpu_index]}%;$cpu_warn;$cpu_crit"
        done
    fi
}

#
# MAIN
#

#
# set default values
#
mode=${mode:=cpu}
filter=${filter:=.}
tout=${tout:=20}
ha_disabled_rc=${ha_disabled_rc:=0}
ha_local_status_ok=${ha_local_status_ok:=primary}
ha_peer_status_ok=${ha_peer_status_ok:=auxiliary}

check_arguments
# 
# precission calculator 'bc' compat. check
#
if [ -x /usr/local/bin/bc ]; then 
    bc=/usr/local/bin/bc
elif [ -x /usr/bin/bc ] ; then
    bc=/usr/bin/bc
fi

case $mode in
    cpu)
        baseOID='.1.3.6.1.2.1.25.3.3.1.2'
        get_snmp
        process_snmp_noindex
        cpu_check
    ;;

    license)
        baseOID='.1.3.6.1.4.1.2604.5.1.5'
        get_snmp
        license_check
    ;;

    tunnel)
        baseOID='.1.3.6.1.4.1.2604.5.1.6.1.1.1.1'
        id[conid]=1
        id[name]=2
        id[desc]=3
        id[policy]=4
        id[mode]=5
        id[type]=6
        id[port]=7
        id[active]=8
        get_snmp
        process_snmp_namedindex
        check_vpntunnel $filter
    ;;

    ha)
        baseOID='.1.3.6.1.4.1.2604.5.1.4'
        get_snmp
        check_ha
    ;;

    *)
        echo "(UNKNOWN): mode '-m $mode' not known" ; exit 3
    ;;
esac


#
# Tell monitoring system what we found out
#
echo -en "$( state_string $glob_rcode ) $outmsg"
if [ -n "$details" ] ; then echo -en "\n\n$details" ; fi
if [ -n "$perfdata" ] ; then echo -en "|$perfdata" ; fi
echo

exit $glob_rcode


# vim: ts=4:expandtab:sw=4:sts=4:ai:smartindent:filetype=bash

