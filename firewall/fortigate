#!/usr/bin/env python3
#
# Check Fortigate Firewall via API
#
# Version 0.2
#  added cpu, mem, licence checks (without thresholds)
#
# Version 0.1
#
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), '..'))
import argparse
import pprint
from datetime import *
from lib.jsonapi import *
from lib.generic_plugin import *
from datetime import datetime


# # # # # # # # # # # # # # # # # # # # # # # # # 
# MAIN
# # # # # # # # # # # # # # # # # # # # # # # # # 

# parse command line parameters

cli = argparse.ArgumentParser \
    (description='Check Sophos Cloud Services for Endpoint-Status or Alerts')

cli.add_argument('-H', help='Hostname or IP address')
cli.add_argument('--token', help='api access token')
cli.add_argument('--mode', help='select check mode', \
        choices=['version', 'health', 'license', 'cpu', 'mem'])
cli.add_argument('--warn', help='warning theshold', type=int)
cli.add_argument('--crit', help='critical theshold', type=int)
args = cli.parse_args()
#pp = pprint.PrettyPrinter(indent=4, compact=True, sort_dicts=True)

# init vars
rcode=0
out_text=''
detail=''
mode=args.mode
warn=args.warn
crit=args.crit


def sysinfo( host, token ):
    url="https://{}/api/v2/monitor/system/status/?access_token={}".format( host, token )
    jdata=request_json( url )

    output="Hostname: {}, Model: {}, Version {}, Serial: {}".format( \
        jdata.get('results').get('hostname'), \
        jdata.get('results').get('model'), jdata.get('version'), \
        jdata.get('serial') )
    return output

def resource( host, token, res, warn, crit):
    interval='10'
    intname="{}-min".format(interval)
    url="https://{}/api/v2/monitor/system/resource/usage?access_token={}&interval={}-min&resource={}".format(\
            host, token, interval, res )

    jdata=request_json( url )
    output=''
    perfdata=''
    ind=0
    rcode = 0
    for resobj in jdata['results'][res]:
        avg = str( resobj['historical'][intname]['average'] )
        # Convert to int
        avg_int = int(avg)

        # Check threshold and update global rcode
        loop_rc = check_threshold( avg_int, warn, crit )
        rcode = update_rc( loop_rc, rcode )

        output+="{}[{}]: {}% ".format(res, ind, avg)
        perfdata+="{}[{}]={}%;{};{};0;100 ".format(res, ind, avg, warn, crit)
        ind += 1

    output+="  ({} minute average)".format(interval)
    return (output, rcode, perfdata)

def license( host, token, warn, crit):
    url="https://{}/api/v2/monitor/license/status/?access_token={}".format( host, token )
    jdata=request_json( url )
    #pp = pprint.PrettyPrinter(indent=4, compact=True, sort_dicts=True)
    #pp.pprint(jdata.get('results'))

    # get longest key name
    longest = len( max( jdata.get('results').keys(), key=len) )

    rcode=0
    output=''
    details=''
    status_count={}
    for lic in sorted( jdata.get('results').keys() ):
        l_status  = jdata.get('results').get(lic).get('status')

        # --> do not handle this license status
        if l_status == 'no_license' or l_status == None: continue

        if l_status not in status_count:
            status_count[l_status]=1
        else:
            status_count[l_status]+=1

        l_expires = jdata.get('results').get(lic).get('expires')

        now = datetime.now(timezone.utc)
        if l_expires != None:
            exp_date = datetime.fromtimestamp( l_expires, timezone.utc )
            exp_period = ( exp_date - now ).days
            details += "{:<{len}}| {:^17}| expires in {} days\n".format( \
                    lic+':', l_status, exp_period, len=longest )
            loop_rc = check_threshold( exp_period, warn, crit, 'lt' )
            rcode = update_rc( loop_rc, rcode )
            if loop_rc > 0:
                if 'expiring_soon' not in status_count:
                    status_count['expiring_soon']=1
                else:
                    status_count['expiring_soon']+=1
        else:
            details += "{:<{len}}| {:^17}| no expiration date\n".format( \
                    lic, l_status, len=longest )

    output  = 'Licence Check: '
    for stat in status_count:
        output += "{} {}, ".format(status_count[stat], stat)
    output += "\n\n" + details
    return(output, rcode)

perfdata=''
if mode=='version':
    out_text=sysinfo(args.H, args.token)
elif mode=='cpu':
    (out_text, rcode, perfdata)=resource(args.H, args.token, 'cpu', warn, crit)
elif mode=='mem':
    (out_text, rcode, perfdata)=resource(args.H, args.token, 'mem', warn, crit)
elif mode=='license':
    (out_text,rcode)=license(args.H, args.token, warn, crit )
else:
    rcode=3
    out_text='Option "--mode" required'


#Finally, print check output and exit with rcode
if not perfdata:
    print("{} {}".format( rcstring(rcode), out_text ))
else:
    print("{} {}|{}".format( rcstring(rcode), out_text, perfdata ))

sys.exit(rcode)

# vim: ts=4:expandtab:sw=4:sts=4:ai:smartindent:filetype=python

