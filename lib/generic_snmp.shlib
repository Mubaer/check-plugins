#
# Check Plugin Functions for SNMP-Checks
#
# Author: Xin Qu
#
#	Version 1.2 Mon Mar 11 17:19:24 CET 2024
#		imported modular snmp processing from snmp_sophos_sg
#
#	Version 1.1 Mar  7 10:10:38 CET 2024
#		imported 'get_snmp_and_process' from qnap-storage
#
#	Version 1.0 Mar  6 17:00:07 CET 2024
#		New function "get_snmp"
#
#	Version 0.1 Apr  3 16:35:48 CEST 2023
#

function check_snmp_args {
	if [ -z "$hostname" ] ; then
		echo "$0 required argument -H <hostname> missing"
		exit 3
	elif [ -z "$authuser" -a -z "$community" ] ; then
		echo "$0 SNMP credentials missing: either -C <community> or snmp V3:"
		echo "	-u <authuser> -a <authproto> -A <authpass> -x <secproto> -X <secpass> -l <seclevel>"
		exit 3
	fi
}

# gets a single value from a single OID
function get_snmp {
	#
	# Compose snmp command
	#
	local oid=$1
	if [ -n "$authuser" ]; then snmpv=3; else snmpv=2c; fi

	local snmpcmd="snmpget -Onq -v $snmpv -t $tout -r 3 \
		$community $authuser $privproto $privpass $seclevel $authproto $authpass \
		$hostname  $oid"

	dbg_msg "debug: $snmpcmd"

	# First of all, get the SNMP-Data
	local snmpResponse=$($snmpcmd 2>&1)
	local snmpexit=$?

	dbg_msg "$snmpResponse"

	if [ $snmpexit -ne 0 ] ; then
		echo "(UNKNOWN): Problem fetching SNMP data."
		echo
		echo "SNMP Output was: $snmpResponse"
		exit 3
	fi

	while read oid value unit
	do
		snmpData[$oid]="$value"
		snmpUnit[$oid]="$unit"
	done <<< "$snmpResponse"
}

function get_snmp_lib {
	# Function parameters
	local units=$1
	local nobulk=$2
	case $units in
		nounit*)
			units=no ;;
		# Handling units is the default	
		*)
			units=yes ;;
	esac

	#
	# Compose snmp command
	#
	if [ "$nobulk" ]; then walk=snmpwalk;  else walk=snmpbulkwalk; fi
	if [ -n "$authuser" ]; then snmpv=3; else snmpv=2c; fi

	snmpcmd="$walk -Onqt -v $snmpv -t $tout -r 3 \
		$community $authuser $privproto $privpass $seclevel $authproto $authpass \
		$hostname  $baseOID"

	dbg_msg "debug snmpcmd: $snmpcmd"


	# First of all, get the SNMP-Data
	snmpResponse=$($snmpcmd 2>&1)
	snmpexit=$?

	dbg_msg "debugsnmpresponse:\n$snmpResponse"

	if [ $snmpexit -ne 0 ] ; then
		echo "(UNKNOWN): Problem fetching SNMP data."
		echo
		echo "SNMP Output was: $snmpResponse"
		exit 3
	fi

	if [[ "$snmpResponse" =~ 'No Such Object available' ]] ;then
		snmpData[err]='nosuchobject'
	fi

	if [ "$units" == 'yes' ] ; then
		# Treat value after first space as unit
		while read oid value unit
		do
			snmpData[$oid]="$value"
			if [ -n "$unit" ] ; then
				snmpUnit[$oid]="$unit"
			fi
		done <<< "$snmpResponse"
	else
		# Put everything into "value"
		while read oid value
		do
			snmpData[$oid]="$value"
		done <<< "$snmpResponse"
	fi
}

# gets a bulk of OIDs and processes SNMP-Tables if
# a value for 'id[index]' and 'id[name]' is given
function get_snmp_and_process {
	#
	# Compose snmp command
	#
	local -a elementIndex
	if [ "$nobulk" ]; then walk=snmpwalk;  else walk=snmpbulkwalk; fi
	if [ -n "$authuser" ]; then snmpv=3; else snmpv=2c; fi

	snmpcmd="$walk -Onq -v $snmpv -t $tout -r 3 \
		$community $authuser $privproto $privpass $seclevel $authproto $authpass \
		$hostname  $baseOID"

	dbg_msg "debug: $snmpcmd"

	# First of all, get the SNMP-Data
	snmpResponse=$($snmpcmd 2>&1)
	snmpexit=$?

	dbg_msg "$snmpResponse"

	if [ $snmpexit -ne 0 ] ; then
		echo "(UNKNOWN): Problem fetching SNMP data."
		echo
		echo "SNMP Output was: $snmpResponse"
		exit 3
	fi

	while read oid value unit
	do
		snmpData[$oid]="$value"
		snmpUnit[$oid]="$unit"
	done <<< "$snmpResponse"

	#### building indexes
	#
	# (only when a index is defined)

	# build element index
	if [ -n "${id[index]}" ] ; then
		for key in ${!snmpData[@]} ; do
			if [[ $key == "$baseOID.${id[index]}"* ]] ; then
			elementIndex+=( ${snmpData[$key]} )
			fi
		done

		# build name map
		for element in	${elementIndex[@]};do
			nameMap[${snmpData[${baseOID}.${id[name]}.$element]}${snmpUnit[${baseOID}.${id[name]}.$element]}]=${snmpData[${baseOID}.${id[index]}.$element]}
		done
		fi

	#
	#
	#### / building indexes
}


function get_bulk_snmp {
	#
	# Compose snmp command
	#
	if [ "$nobulk" ]; then walk=snmpwalk;  else walk=snmpbulkwalk; fi
	if [ -n "$authuser" ]; then snmpv=3; else snmpv=2c; fi

	local snmpcmd="$walk -Onq -v $snmpv -t $tout -r 3 \
		$community $authuser $privproto $privpass $seclevel $authproto $authpass \
		$hostname  $baseOID"

	dbg_msg "snmpcmd: $snmpcmd"

	# First of all, get the SNMP-Data
	local snmpResponse=$($snmpcmd 2>&1)
	local snmpexit=$?

	dbg_msg "snmpresponse: $snmpResponse"

	if [ $snmpexit -ne 0 ] ; then
		echo "(UNKNOWN): Problem fetching SNMP data."
		echo
		echo "SNMP Output was: $snmpResponse"
		exit 3
	fi

	while read oid value unit
	do
		snmpData[$oid]="$value"
		snmpUnit[$oid]="$unit"
	done <<< "$snmpResponse"
}

function process_snmp_index {
	#### building indexes
	# required id[index] and id[name] set
	#

	# build element index
	for key in ${!snmpData[@]} ; do
		if [[ $key == "$baseOID.${id[index]}"* ]] ; then
		elementIndex+=( ${snmpData[$key]} )
		fi
	done

	# build name map
	local element
	for element in	${elementIndex[@]}
	do
		nameMap[${snmpData[${baseOID}.${id[name]}.$element]}]=${snmpData[${baseOID}.${id[index]}.$element]}
	done
	#
	#
	#### / building indexes
	dbg_msg "DEBUG values [nameMap]: ${nameMap[*]}"
	dbg_msg "DEBUG keys   [nameMap]: ${!nameMap[*]}"
}

function process_snmp_noindex {
	#### building indexes
	# for pure lists without an 'index'
	#

	# build element list
	local element_counter=0
	for element in ${snmpData[@]} ; do
			elementList[$element_counter]=$element
			: $(( element_counter++ ))
	done
	dbg_msg "DEBUG [elementList]: ${elementList[@]}"
}

function process_snmp_namedindex {
	#### building indexes
	# for tables without an 'index' column, use last OID part as index
	#

	# build element index. Last OID-Tree-Level is the index
	for key in ${!snmpData[@]} ; do
		dbg_msg "testing whether $key matches $baseOID.${id[name]}"
		if [[ $key == "$baseOID.${id[name]}".* ]] ; then
			dbg_msg "match!"
			key=${key/.*\./}
			elementList+=( $key )
		fi
	done
	dbg_msg "DEBUG [elementList]: ${elementList[*]}"

	# build name map
	local element
	local namePart1
	local namePart2
	for element in	${elementList[@]}
	do
		namePart1="${snmpData[${baseOID}.${id[name]}.$element]}"
		namePart2="${snmpUnit[${baseOID}.${id[name]}.$element]}"
		if [ -z "$namePart2" ] ; then
			nameMap[$namePart1]=$element
		else
			nameMap[${namePart1} ${namePart2}]=$element
		fi
	done
	#
	#
	#### / building indexes
	dbg_msg "DEBUG [nameMap]: ${nameMap[*]}"
}

function process_snmp_namedindex_flex {
	#### building indexes
	# for tables without an 'index' column, use last OID part as index
	# same es process_snmp_namedindex, but use whole OID subtree as index
	#

	# build element index. Last OID-Tree-Level is the index
	local index_oid
	for key in ${!snmpData[@]} ; do
		index_oid="$baseOID.${id[name]}"
		if [[ $key == "$index_oid".* ]] ; then
		key=${key/$index_oid\./}
		elementList+=( $key )
		fi
	done
	dbg_msg "DEBUG [elementList]: ${elementList[*]}"

	# build name map
	local element
	local namePart1
	local namePart2
	for element in	${elementList[@]}
	do
		namePart1="${snmpData[${baseOID}.${id[name]}.$element]}"
		namePart2="${snmpUnit[${baseOID}.${id[name]}.$element]}"
		if [ -z "$namePart2" ] ; then
			nameMap[$namePart1]=$element
		else
			nameMap[${namePart1} ${namePart2}]=$element
		fi
	done
	#
	#
	#### / building indexes
	dbg_msg "DEBUG [nameMap]: ${nameMap[*]}"
	dbg_msg "DEBUG [nameMap]: ${!nameMap[*]}"
}
# vim: filetype=bash

# Test for errors generated by get_snmp_lib
function test_errors {
	local prefix=$1
	local object=$2

	outmsg="$prefix"
	case ${snmpData[err]} in
		nosuchobject)
			outmsg+="Device does not have any $object."
			glob_rcode=0
			trigger_exit
			;;
	esac
}

